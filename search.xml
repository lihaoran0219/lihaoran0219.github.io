<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树的最近公共祖先</title>
      <link href="/lihaoran0219.github.io/2020/05/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/lihaoran0219.github.io/2020/05/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://img-blog.csdnimg.cn/20200510173402658.png" alt="在这里插入图片描述"><br>示例 1:</p><pre><code>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</code></pre><p>示例 2:</p><pre><code>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>说明:</p><pre><code>所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>分别递归遍历左右子树：    如果p,q分别在左右子树，则最近公共祖先只能是根节点    如果p,q在同一子树上，先找到的就是最近公共祖先</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);<span class="comment">//遍历左子树</span></span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);<span class="comment">//遍历右子树</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)<span class="comment">//左右都不为空说明pq分别在左右子树上，最近公共祖先</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//p,q在同一子树上</span></span><br><span class="line">            <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis笔记</title>
      <link href="/lihaoran0219.github.io/2020/04/25/redis%E7%AC%94%E8%AE%B0/"/>
      <url>/lihaoran0219.github.io/2020/04/25/redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库    1.1.什么是NOSQL        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。        1.1.1.    NOSQL和关系型数据库比较            优点：                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。            缺点：                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。                3）不提供关系型数据库对事务的处理。        1.1.2.    非关系型数据库的优势：            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。        1.1.3.    关系型数据库的优势：            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。        1.1.4.    总结            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，            让NoSQL数据库对关系型数据库的不足进行弥补。            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据    1.2.主流的NOSQL产品        •    键值(Key-Value)存储数据库                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。                 数据模型： 一系列键值对                优势： 快速查询                劣势： 存储的数据缺少结构化        •    列存储数据库                相关产品：Cassandra, HBase, Riak                典型应用：分布式的文件系统                数据模型：以列簇式存储，将同一列数据存在一起                优势：查找速度快，可扩展性强，更容易进行分布式扩展                劣势：功能相对局限        •    文档型数据库                相关产品：CouchDB、MongoDB                典型应用：Web应用（与Key-Value类似，Value是结构化的）                数据模型： 一系列键值对                优势：数据结构要求不严格                劣势： 查询性能不高，而且缺乏统一的查询语法        •    图形(Graph)数据库                相关数据库：Neo4J、InfoGrid、Infinite Graph                典型应用：社交网络                数据模型：图结构                优势：利用图结构相关算法。                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。    1.3 什么是Redis        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：            1) 字符串类型 string            2) 哈希类型 hash            3) 列表类型 list            4) 集合类型 set            5) 有序集合类型 sortedset        1.3.1 redis的应用场景            •    缓存（数据查询、短连接、新闻内容、商品内容等等）            •    聊天室的在线好友列表            •    任务队列。（秒杀、抢购、12306等等）            •    应用排行榜            •    网站访问统计            •    数据过期处理（可以精确到毫秒            •    分布式集群架构中的session分离2. 下载安装    1. 官网：https://redis.io    2. 中文网：http://www.redis.net.cn/    3. 解压直接可以使用：        * redis.windows.conf：配置文件        * redis-cli.exe：redis的客户端        * redis-server.exe：redis服务器端3. 命令操作    1. redis的数据结构：        * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构            * value的数据结构：                1) 字符串类型 string                2) 哈希类型 hash ： map格式                  3) 列表类型 list ： linkedlist格式。支持重复元素                4) 集合类型 set  ： 不允许重复元素                5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序    2. 字符串类型 string        1. 存储： set key value            127.0.0.1:6379&gt; set username zhangsan            OK        2. 获取： get key            127.0.0.1:6379&gt; get username            &quot;zhangsan&quot;        3. 删除： del key            127.0.0.1:6379&gt; del age            (integer) 1    3. 哈希类型 hash        1. 存储： hset key field value            127.0.0.1:6379&gt; hset myhash username lisi            (integer) 1            127.0.0.1:6379&gt; hset myhash password 123            (integer) 1        2. 获取：             * hget key field: 获取指定的field对应的值                127.0.0.1:6379&gt; hget myhash username                &quot;lisi&quot;            * hgetall key：获取所有的field和value                127.0.0.1:6379&gt; hgetall myhash                1) &quot;username&quot;                2) &quot;lisi&quot;                3) &quot;password&quot;                4) &quot;123&quot;        3. 删除： hdel key field            127.0.0.1:6379&gt; hdel myhash username            (integer) 1    4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）        1. 添加：            1. lpush key value: 将元素加入列表左表            2. rpush key value：将元素加入列表右边                127.0.0.1:6379&gt; lpush myList a                (integer) 1                127.0.0.1:6379&gt; lpush myList b                (integer) 2                127.0.0.1:6379&gt; rpush myList c                (integer) 3        2. 获取：            * lrange key start end ：范围获取                127.0.0.1:6379&gt; lrange myList 0 -1                1) &quot;b&quot;                2) &quot;a&quot;                3) &quot;c&quot;        3. 删除：            * lpop key： 删除列表最左边的元素，并将元素返回            * rpop key： 删除列表最右边的元素，并将元素返回    5. 集合类型 set ： 不允许重复元素        1. 存储：sadd key value            127.0.0.1:6379&gt; sadd myset a            (integer) 1            127.0.0.1:6379&gt; sadd myset a            (integer) 0        2. 获取：smembers key:获取set集合中所有元素            127.0.0.1:6379&gt; smembers myset            1) &quot;a&quot;        3. 删除：srem key value:删除set集合中的某个元素                127.0.0.1:6379&gt; srem myset a            (integer) 1    6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。        1. 存储：zadd key score value            127.0.0.1:6379&gt; zadd mysort 60 zhangsan            (integer) 1            127.0.0.1:6379&gt; zadd mysort 50 lisi            (integer) 1            127.0.0.1:6379&gt; zadd mysort 80 wangwu            (integer) 1        2. 获取：zrange key start end [withscores]            127.0.0.1:6379&gt; zrange mysort 0 -1            1) &quot;lisi&quot;            2) &quot;zhangsan&quot;            3) &quot;wangwu&quot;            127.0.0.1:6379&gt; zrange mysort 0 -1 withscores            1) &quot;zhangsan&quot;            2) &quot;60&quot;            3) &quot;wangwu&quot;            4) &quot;80&quot;            5) &quot;lisi&quot;            6) &quot;500&quot;        3. 删除：zrem key value            127.0.0.1:6379&gt; zrem mysort lisi            (integer) 1    7. 通用命令        1. keys * : 查询所有的键        2. type key ： 获取键对应的value的类型        3. del key：删除指定的key value4. 持久化    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。    2. redis持久化机制：        1. RDB：默认方式，不需要进行配置，默认就使用这种机制            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据            1. 编辑redis.windwos.conf文件                #   after 900 sec (15 min) if at least 1 key changed                save 900 1                #   after 300 sec (5 min) if at least 10 keys changed                save 300 10                #   after 60 sec if at least 10000 keys changed                save 60 10000            2. 重新启动redis服务器，并指定配置文件名称                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据            1. 编辑redis.windwos.conf文件                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）                # appendfsync always ： 每一次操作都进行持久化                appendfsync everysec ： 每隔一秒进行一次持久化                # appendfsync no     ： 不进行持久化5. Java客户端 Jedis    * Jedis: 一款java操作redis数据库的工具.    * 使用步骤：        1. 下载jedis的jar包        2. 使用            //1. 获取连接            Jedis jedis = new Jedis(&quot;localhost&quot;,6379);               //2. 操作               jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //3. 关闭连接            jedis.close();    * Jedis操作各种redis中的数据结构        1) 字符串类型 string            set            get             //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            //存储            jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //获取            String username = jedis.get(&quot;username&quot;);            System.out.println(username);            //可以使用setex()方法存储可以指定过期时间的 key value            jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对            //3. 关闭连接            jedis.close();        2) 哈希类型 hash ： map格式              hset            hget            hgetAll            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // 存储hash            jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);            jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);            jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);            // 获取hash            String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);            System.out.println(name);            // 获取hash的所有map中的数据            Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;);            // keyset            Set&lt;String&gt; keySet = user.keySet();            for (String key : keySet) {                //获取value                String value = user.get(key);                System.out.println(key + &quot;:&quot; + value);            }            //3. 关闭连接            jedis.close();        3) 列表类型 list ： linkedlist格式。支持重复元素            lpush / rpush            lpop / rpop            lrange start end : 范围获取             //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // list 存储            jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存            jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存            // list 范围获取            List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist);            // list 弹出            String element1 = jedis.lpop(&quot;mylist&quot;);//c            System.out.println(element1);            String element2 = jedis.rpop(&quot;mylist&quot;);//c            System.out.println(element2);            // list 范围获取            List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist2);            //3. 关闭连接            jedis.close();        4) 集合类型 set  ： 不允许重复元素            sadd            smembers:获取所有元素            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // set 存储            jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);            // set 获取            Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);            System.out.println(myset);            //3. 关闭连接            jedis.close();        5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序            zadd            zrange            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // sortedset 存储            jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);            jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);            jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);            // sortedset 获取            Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);            System.out.println(mysortedset);            //3. 关闭连接            jedis.close();    * jedis连接池： JedisPool        * 使用：            1. 创建JedisPool连接池对象            2. 调用方法 getResource()方法获取Jedis连接                //0.创建一个配置对象                JedisPoolConfig config = new JedisPoolConfig();                config.setMaxTotal(50);                config.setMaxIdle(10);                //1.创建Jedis连接池对象                JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379);                //2.获取连接                Jedis jedis = jedisPool.getResource();                //3. 使用                jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);                //4. 关闭 归还到连接池中                jedis.close();        * 连接池工具类            public class JedisPoolUtils {                private static JedisPool jedisPool;                static{                    //读取配置文件                    InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);                    //创建Properties对象                    Properties pro = new Properties();                    //关联文件                    try {                        pro.load(is);                    } catch (IOException e) {                        e.printStackTrace();                    }                    //获取数据，设置到JedisPoolConfig中                    JedisPoolConfig config = new JedisPoolConfig();                    config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));                    config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));                    //初始化JedisPool                    jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));                }                /**                 * 获取连接方法                 */                public static Jedis getJedis(){                    return jedisPool.getResource();                }            }</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：    1. 提供index.html页面，页面中有一个省份 下拉列表    2. 当 页面加载完成后 发送ajax请求，加载所有省份* 注意：使用redis缓存一些不经常发生变化的数据。    * 数据库的数据一旦发生改变，则需要更新缓存。        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入        * 在service对应的增删改方法中，将redis数据删除。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response笔记</title>
      <link href="/lihaoran0219.github.io/2020/04/22/Response%E7%AC%94%E8%AE%B0/"/>
      <url>/lihaoran0219.github.io/2020/04/22/Response%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><pre><code>1. 请求消息：客户端发送给服务器端的数据    * 数据格式：        1. 请求行        2. 请求头        3. 请求空行        4. 请求体2. 响应消息：服务器端发送给客户端的数据    * 数据格式：        1. 响应行            1. 组成：协议/版本 响应状态码 状态码描述            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。                1. 状态码都是3位数字                 2. 分类：                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码                    2. 2xx：成功。代表：200                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)                    4. 4xx：客户端错误。                        * 代表：                            * 404（请求路径没有对应的资源）                             * 405：请求方式没有对应的doXxx方法                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)        2. 响应头：            1. 格式：头名称： 值            2. 常见的响应头：                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据                    * 值：                        * in-line:默认值,在当前页面内打开                        * attachment;filename=xxx：以附件形式打开响应体。文件下载        3. 响应空行        4. 响应体:传输的数据    * 响应字符串格式        HTTP/1.1 200 OK        Content-Type: text/html;charset=UTF-8        Content-Length: 101        Date: Wed, 06 Jun 2018 07:08:42 GMT        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;$Title$&lt;/title&gt;          &lt;/head&gt;          &lt;body&gt;          hello , response          &lt;/body&gt;        &lt;/html&gt;</code></pre><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息    1. 设置响应行        1. 格式：HTTP/1.1 200 ok        2. 设置状态码：setStatus(int sc)     2. 设置响应头：setHeader(String name, String value)     3. 设置响应体：        * 使用步骤：            1. 获取输出流                * 字符输出流：PrintWriter getWriter()                * 字节输出流：ServletOutputStream getOutputStream()            2. 使用输出流，将数据输出到客户端浏览器* 案例：    1. 完成重定向        * 重定向：资源跳转的方式        * 代码实现：            //1. 设置状态码为302            response.setStatus(302);            //2.设置响应头location            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);            //简单的重定向方法            response.sendRedirect(&quot;/day15/responseDemo2&quot;);        * 重定向的特点:redirect            1. 地址栏发生变化            2. 重定向可以访问其他站点(服务器)的资源            3. 重定向是两次请求。不能使用request对象来共享数据        * 转发的特点：forward            1. 转发地址栏路径不变            2. 转发只能访问当前服务器下的资源            3. 转发是一次请求，可以使用request对象来共享数据        * forward 和  redirect 区别        * 路径写法：            1. 路径分类                1. 相对路径：通过相对路径不可以确定唯一资源                    * 如：./index.html                    * 不以/开头，以.开头路径                    * 规则：找到当前资源和目标资源之间的相对位置关系                        * ./：当前目录                        * ../:后退一级目录                2. 绝对路径：通过绝对路径可以确定唯一资源                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2                    * 以/开头的路径                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)                            * 建议虚拟目录动态获取：request.getContextPath()                            * &lt;a&gt; , &lt;form&gt; 重定向...                        * 给服务器使用：不需要加虚拟目录                            * 转发路径    2. 服务器输出字符数据到浏览器        * 步骤：            1. 获取字符输出流            2. 输出数据        * 注意：            * 乱码问题：                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1                2. 设置该流的默认编码                3. 告诉浏览器响应体使用的编码                //简单的形式，设置编码，是在获取流之前设置                response.setContentType(&quot;text/html;charset=utf-8&quot;);    3. 服务器输出字节数据到浏览器        * 步骤：            1. 获取字节输出流            2. 输出数据    4. 验证码        1. 本质：图片        2. 目的：防止恶意表单注册</code></pre><h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信2. 获取：    1. 通过request对象获取        request.getServletContext();    2. 通过HttpServlet获取        this.getServletContext();3. 功能：    1. 获取MIME类型：        * MIME类型:在互联网通信过程中定义的一种文件数据类型            * 格式： 大类型/小类型   text/html        image/jpeg        * 获取：String getMimeType(String file)      2. 域对象：共享数据        1. setAttribute(String name,Object value)        2. getAttribute(String name)        3. removeAttribute(String name)        * ServletContext对象范围：所有用户所有请求的数据    3. 获取文件的真实(服务器)路径        1. 方法：String getRealPath(String path)               String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问             System.out.println(b);            String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问            System.out.println(c);            String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问            System.out.println(a);</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：    1. 页面显示超链接    2. 点击超链接后弹出下载提示框    3. 完成图片文件下载* 分析：    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求    2. 任何资源都必须弹出下载提示框    3. 使用响应头设置资源的打开方式：        * content-disposition:attachment;filename=xxx* 步骤：    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename    2. 定义Servlet        1. 获取文件名称        2. 使用字节输入流加载文件进内存        3. 指定response的响应头： content-disposition:attachment;filename=xxx        4. 将数据写出到response输出流* 问题：    * 中文文件问题        * 解决思路：            1. 获取客户端使用的浏览器版本信息            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coolie&amp;Session笔记</title>
      <link href="/lihaoran0219.github.io/2020/04/22/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/Cookie&amp;Session%E7%AC%94%E8%AE%B0/"/>
      <url>/lihaoran0219.github.io/2020/04/22/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/Cookie&amp;Session%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><pre><code>1. 会话：一次会话中包含多次请求和响应。    * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止2. 功能：在一次会话的范围内的多次请求间，共享数据3. 方式：    1. 客户端会话技术：Cookie    2. 服务器端会话技术：Session</code></pre><a id="more"></a><h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2><pre><code>1. 概念：客户端会话技术，将数据保存到客户端2. 快速入门：    * 使用步骤：        1. 创建Cookie对象，绑定数据            * new Cookie(String name, String value)         2. 发送Cookie对象            * response.addCookie(Cookie cookie)         3. 获取Cookie，拿到数据            * Cookie[]  request.getCookies()  3. 实现原理    * 基于响应头set-cookie和请求头cookie实现4. cookie的细节    1. 一次可不可以发送多个cookie?        * 可以        * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。    2. cookie在浏览器中保存多长时间？        1. 默认情况下，当浏览器关闭后，Cookie数据被销毁        2. 持久化存储：            * setMaxAge(int seconds)                1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效                2. 负数：默认值                3. 零：删除cookie信息    3. cookie能不能存中文？        * 在tomcat 8 之前 cookie中不能直接存储中文数据。            * 需要将中文数据转码---一般采用URL编码(%E3)        * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析    4. cookie共享问题？        1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？            * 默认情况下cookie不能共享            * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录                * 如果要共享，则可以将path设置为&quot;/&quot;        2. 不同的tomcat服务器间cookie共享问题？            * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享                * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享5. Cookie的特点和作用    1. cookie存储数据在客户端浏览器    2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)    * 作用：        1. cookie一般用于存出少量的不太敏感的数据        2. 在不登录的情况下，完成服务器对客户端的身份识别6. 案例：记住上一次访问时间    1. 需求：        1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。        2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串    2. 分析：        1. 可以采用Cookie来完成        2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie            1. 有：不是第一次访问                1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20                2. 写回Cookie：lastTime=2018年6月10日11:50:01            2. 没有：是第一次访问                1. 响应数据：您好，欢迎您首次访问                2. 写回Cookie：lastTime=2018年6月10日11:50:01    3. 代码实现：        package cn.itcast.cookie;        import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.Cookie;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;        import java.net.URLDecoder;        import java.net.URLEncoder;        import java.text.SimpleDateFormat;        import java.util.Date;    @WebServlet(&quot;/cookieTest&quot;)    public class CookieTest extends HttpServlet {        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            //设置响应的消息体的数据格式以及编码            response.setContentType(&quot;text/html;charset=utf-8&quot;);            //1.获取所有Cookie            Cookie[] cookies = request.getCookies();            boolean flag = false;//没有cookie为lastTime            //2.遍历cookie数组            if(cookies != null &amp;&amp; cookies.length &gt; 0){                for (Cookie cookie : cookies) {                    //3.获取cookie的名称                    String name = cookie.getName();                    //4.判断名称是否是：lastTime                    if(&quot;lastTime&quot;.equals(name)){                        //有该Cookie，不是第一次访问                        flag = true;//有lastTime的cookie                        //设置Cookie的value                        //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                        Date date  = new Date();                        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                        String str_date = sdf.format(date);                        System.out.println(&quot;编码前：&quot;+str_date);                        //URL编码                        str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                        System.out.println(&quot;编码后：&quot;+str_date);                        cookie.setValue(str_date);                        //设置cookie的存活时间                        cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                        response.addCookie(cookie);                        //响应数据                        //获取Cookie的value，时间                        String value = cookie.getValue();                        System.out.println(&quot;解码前：&quot;+value);                        //URL解码：                        value = URLDecoder.decode(value,&quot;utf-8&quot;);                        System.out.println(&quot;解码后：&quot;+value);                        response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;);                        break;                    }                }            }            if(cookies == null || cookies.length == 0 || flag == false){                //没有，第一次访问                //设置Cookie的value                //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                Date date  = new Date();                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                String str_date = sdf.format(date);                System.out.println(&quot;编码前：&quot;+str_date);                //URL编码                str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                System.out.println(&quot;编码后：&quot;+str_date);                Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);                //设置cookie的存活时间                cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                response.addCookie(cookie);                response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;);            }        }        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            this.doPost(request, response);        }    }</code></pre><h2 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h2><pre><code>1. 概念：    * Java Server Pages： java服务器端页面        * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码        * 用于简化书写！！！2. 原理    * JSP本质上就是一个Servlet3. JSP的脚本：JSP定义Java代码的方式    1. &lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。    2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。    3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。4. JSP的内置对象：    * 在jsp页面中不需要获取和创建，可以直接使用的对象    * jsp一共有9个内置对象。    * 今天学习3个：        * request        * response        * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似            * response.getWriter()和out.write()的区别：                * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。                * response.getWriter()数据输出永远在out.write()之前5. 案例:改造Cookie案例</code></pre><h2 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h2><pre><code>1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession2. 快速入门：    1. 获取HttpSession对象：        HttpSession session = request.getSession();    2. 使用HttpSession对象：        Object getAttribute(String name)          void setAttribute(String name, Object value)        void removeAttribute(String name)  3. 原理    * Session的实现是依赖于Cookie的。4. 细节：    1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？        * 默认情况下。不是。        * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。             Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());             c.setMaxAge(60*60);             response.addCookie(c);    2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？        * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作            * session的钝化：                * 在服务器正常关闭之前，将session对象系列化到硬盘上            * session的活化：                * 在服务器启动后，将session文件转化为内存中的session对象即可。    3. session什么时候被销毁？        1. 服务器关闭        2. session对象调用invalidate() 。        3. session默认失效时间 30分钟            选择性配置修改                &lt;session-config&gt;                &lt;session-timeout&gt;30&lt;/session-timeout&gt;            &lt;/session-config&gt; 5. session的特点     1. session用于存储一次会话的多次请求的数据，存在服务器端     2. session可以存储任意类型，任意大小的数据    * session与Cookie的区别：        1. session存储数据在服务器端，Cookie在客户端        2. session没有数据大小限制，Cookie有        3. session数据安全，Cookie相对于不安全</code></pre><h2 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h2><pre><code>1. 案例需求：    1. 访问带有验证码的登录页面login.jsp    2. 用户输入用户名，密码以及验证码。        * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误        * 如果验证码输入有误，跳转登录页面，提示：验证码错误        * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您2. 分析：</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit</title>
      <link href="/lihaoran0219.github.io/2020/04/21/Junit/"/>
      <url>/lihaoran0219.github.io/2020/04/21/Junit/</url>
      
        <content type="html"><![CDATA[<h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><pre><code>* 测试分类：    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。    2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试    * 步骤：        1. 定义一个测试类(测试用例)            * 建议：                * 测试类名：被测试的类名Test        CalculatorTest                * 包名：xxx.xxx.xx.test        cn.itcast.test        2. 定义测试方法：可以独立运行            * 建议：                * 方法名：test测试的方法名        testAdd()                  * 返回值：void                * 参数列表：空参        3. 给方法加@Test        4. 导入junit依赖环境    * 判定结果：        * 红色：失败        * 绿色：成功        * 一般我们会使用断言操作来处理结果            * Assert.assertEquals(期望的结果,运算的结果);    * 补充：        * @Before:            * 修饰的方法会在测试方法之前被自动执行        * @After:            * 修饰的方法会在测试方法执行之后自动被执行</code></pre><a id="more"></a><h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class：通过类名的属性class获取        * 多用于参数的传递    3. 对象.getClass()：getClass()方法在Object类中定义着。        * 多用于对象的获取字节码的方式    * 结论：        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFields() ：获取所有public修饰的成员变量            * Field getField(String name)   获取指定名称的 public修饰的成员变量            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符            * Field getDeclaredField(String name)          2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()              * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;?&gt;[] getDeclaredConstructors()          3. 获取成员方法们：            * Method[] getMethods()              * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)              * Method[] getDeclaredMethods()              * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)          4. 获取全类名                * String getName()  * Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)          2. 获取值            * get(Object obj)         3. 忽略访问权限修饰符的安全检查            * setAccessible(true):暴力反射* Constructor:构造方法    * 创建对象：        * T newInstance(Object... initargs)          * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)      * 获取方法名称：        * String getName:获取方法名* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        * 实现：            1. 配置文件            2. 反射        * 步骤：            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中            2. 在程序中加载读取配置文件            3. 使用反射技术来加载类文件进内存            4. 创建对象            5. 执行方法</code></pre><h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><pre><code>* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述：    * JDK1.5之后的新特性    * 说明程序的    * 使用注解：@注解名称* 作用分类：    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】* JDK中预定义的一些注解    * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的    * @Deprecated：该注解标注的内容，表示已过时    * @SuppressWarnings：压制警告        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)* 自定义注解    * 格式：        元注解        public @interface 注解名称{            属性列表;        }    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口        * public interface MyAnno extends java.lang.annotation.Annotation {}    * 属性：接口中的抽象方法        * 要求：            1. 属性的返回值类型有下列取值                * 基本数据类型                * String                * 枚举                * 注解                * 以上类型的数组            2. 定义了属性，在使用时需要给属性赋值                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。                3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略    * 元注解：用于描述注解的注解        * @Target：描述注解能够作用的位置            * ElementType取值：                * TYPE：可以作用于类上                * METHOD：可以作用于方法上                * FIELD：可以作用于成员变量上        * @Retention：描述注解被保留的阶段            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到        * @Documented：描述注解是否被抽取到api文档中        * @Inherited：描述注解是否被子类继承* 在程序使用(解析)注解：获取注解中定义的属性值    1. 获取注解定义的位置的对象  （Class，Method,Field）    2. 获取指定的注解        * getAnnotation(Class)        //其实就是在内存中生成了一个该注解接口的子类实现对象                public class ProImpl implements Pro{                    public String className(){                        return &quot;cn.itcast.annotation.Demo1&quot;;                    }                    public String methodName(){                        return &quot;show&quot;;                    }                }    3. 调用注解中的抽象方法获取配置的属性值* 案例：简单的测试框架* 小结：    1. 以后大多数时候，我们会使用注解，而不是自定义注解    2. 注解给谁用？        1. 编译器        2. 给解析程序用    3. 注解不是程序的一部分，可以理解为注解就是一个标签</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat&amp;Servlet</title>
      <link href="/lihaoran0219.github.io/2020/04/21/Tomcat&amp;Servlet%E7%AC%94%E8%AE%B0/"/>
      <url>/lihaoran0219.github.io/2020/04/21/Tomcat&amp;Servlet%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>8</p><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人        * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称        * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。* 快速入门：    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;</code></pre><ul><li><p>执行原理：<br><img src="https://img-blog.csdnimg.cn/20200421163205237.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><pre><code>1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。3. 如果有，则再找到对应的&lt;servlet-class&gt;全类名4. tomcat会将字节码文件加载进内存，并且创建其对象5. 调用其方法</code></pre><ul><li><p>Servlet中的生命周期方法：</p><pre><code>1. 被创建：执行init方法，只执行一次    * Servlet什么时候被创建？        * 默认情况下，第一次被访问时，Servlet被创建        * 可以配置执行Servlet的创建时机。            * 在&lt;servlet&gt;标签下配置                1. 第一次被访问时，创建                    * &lt;load-on-startup&gt;的值为负数                2. 在服务器启动时，创建                    * &lt;load-on-startup&gt;的值为0或正整数</code></pre></li></ul></li></ul><pre><code>            * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的                * 多个用户同时访问时，可能存在线程安全问题。                * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值        2. 提供服务：执行service方法，执行多次            * 每次访问Servlet时，Service方法都会被调用一次。        3. 被销毁：执行destroy方法，只执行一次            * Servlet被销毁时执行。服务器关闭时，Servlet被销毁            * 只有服务器正常关闭时，才会执行destroy方法。            * destroy方法在Servlet被销毁之前执行，一般用于释放资源* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置           @WebServlet(&quot;资源路径&quot;)```java                @Target({ElementType.TYPE})                @Retention(RetentionPolicy.RUNTIME)                @Documented                public @interface WebServlet {                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                String[] value() default {};//代表urlPatterns()属性配置                String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                WebInitParam[] initParams() default {};                boolean asyncSupported() default false;                String smallIcon() default &quot;&quot;;                String largeIcon() default &quot;&quot;;                String description() default &quot;&quot;;                String displayName() default &quot;&quot;;            }</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet&amp;HTTp&amp;Request</title>
      <link href="/lihaoran0219.github.io/2020/04/21/Servlet&amp;HTTP&amp;Request%E7%AC%94%E8%AE%B0/"/>
      <url>/lihaoran0219.github.io/2020/04/21/Servlet&amp;HTTP&amp;Request%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><pre><code>1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0 注解配置6. Servlet的体系结构        Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法7. Servlet相关配置    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre><h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><pre><code>* 概念：Hyper Text Transfer Protocol 超文本传输协议    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式    * 特点：        1. 基于TCP/IP的高级协议        2. 默认端口号:80        3. 基于请求/响应模型的:一次请求对应一次响应        4. 无状态的：每次请求之间相互独立，不能交互数据    * 历史版本：        * 1.0：每一次请求响应都会建立新的连接        * 1.1：复用连接* 请求消息数据格式    1. 请求行        请求方式 请求url 请求协议/版本        GET /login.html    HTTP/1.1        * 请求方式：            * HTTP协议有7中请求方式，常用的有2种                * GET：                    1. 请求参数在请求行中，在url后。                    2. 请求的url长度有限制的                    3. 不太安全                * POST：                    1. 请求参数在请求体中                    2. 请求的url长度没有限制的                    3. 相对安全    2. 请求头：客户端浏览器告诉服务器一些信息        请求头名称: 请求头值        * 常见的请求头：            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题            2. Referer：http://localhost/login.html                * 告诉服务器，我(当前请求)从哪里来？                    * 作用：                        1. 防盗链：                        2. 统计工作：    3. 请求空行        空行，就是用于分割POST请求的请求头，和请求体的。    4. 请求体(正文)：        * 封装POST请求消息的请求参数的    * 字符串格式：        POST /login.html    HTTP/1.1        Host: localhost        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2        Accept-Encoding: gzip, deflate        Referer: http://localhost/login.html        Connection: keep-alive        Upgrade-Insecure-Requests: 1        username=zhangsan    * 响应消息数据格式</code></pre><h2 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h2><pre><code>1. request对象和response对象的原理    1. request和response对象是由服务器创建的。我们来使用它们    2. request对象是来获取请求消息，response对象是来设置响应消息2. request对象继承体系结构：        ServletRequest        --    接口        |    继承    HttpServletRequest    -- 接口        |    实现    org.apache.catalina.connector.RequestFacade 类(tomcat)3. request功能：    1. 获取请求消息数据        1. 获取请求行数据            * GET /day14/demo1?name=zhangsan HTTP/1.1            * 方法：                1. 获取请求方式 ：GET                    * String getMethod()                  2. (*)获取虚拟目录：/day14                    * String getContextPath()                3. 获取Servlet路径: /demo1                    * String getServletPath()                4. 获取get方式请求参数：name=zhangsan                    * String getQueryString()                5. (*)获取请求URI：/day14/demo1                    * String getRequestURI():        /day14/demo1                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国                    * URI：统一资源标识符 : /day14/demo1                    共和国                6. 获取协议及版本：HTTP/1.1                    * String getProtocol()                7. 获取客户机的IP地址：                    * String getRemoteAddr()        2. 获取请求头数据            * 方法：                * (*)String getHeader(String name):通过请求头的名称获取请求头的值                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称        3. 获取请求体数据:            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数            * 步骤：                1. 获取流对象                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据                        * 在文件上传知识点后讲解                2. 再从流对象中拿数据    2. 其他功能：        1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数            1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123            2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game            3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称            4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合            * 中文乱码问题：                * get方式：tomcat 8 已经将get方式乱码问题解决了                * post方式：会乱码                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);        2. 请求转发：一种在服务器内部的资源跳转方式            1. 步骤：                1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)                2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)             2. 特点：                1. 浏览器地址栏路径不发生变化                2. 只能转发到当前服务器内部资源中。                3. 转发是一次请求        3. 共享数据：            * 域对象：一个有作用范围的对象，可以在范围内共享数据            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据            * 方法：                1. void setAttribute(String name,Object obj):存储数据                2. Object getAttitude(String name):通过键获取值                3. void removeAttribute(String name):通过键移除键值对        4. 获取ServletContext：            * ServletContext getServletContext()</code></pre><h2 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h2><pre><code>* 用户登录案例需求：    1.编写login.html登录页面        username &amp; password 两个输入框    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表    3.使用JdbcTemplate技术封装JDBC    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误* 分析* 开发步骤    1. 创建项目，导入html页面，配置文件，jar包    2. 创建数据库环境        CREATE DATABASE day14;        USE day14;        CREATE TABLE USER(            id INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(32) UNIQUE NOT NULL,            PASSWORD VARCHAR(32) NOT NULL        );    3. 创建包cn.itcast.domain,创建类User        package cn.itcast.domain;        /**         * 用户的实体类         */        public class User {            private int id;            private String username;            private String password;            public int getId() {                return id;            }            public void setId(int id) {                this.id = id;            }            public String getUsername() {                return username;            }            public void setUsername(String username) {                this.username = username;            }            public String getPassword() {                return password;            }            public void setPassword(String password) {                this.password = password;            }            @Override            public String toString() {                return &quot;User{&quot; +                        &quot;id=&quot; + id +                        &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; +                        &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +                        &apos;}&apos;;            }        }    4. 创建包cn.itcast.util,编写工具类JDBCUtils        package cn.itcast.util;        import com.alibaba.druid.pool.DruidDataSourceFactory;        import javax.sql.DataSource;        import javax.xml.crypto.Data;        import java.io.IOException;        import java.io.InputStream;        import java.sql.Connection;        import java.sql.SQLException;        import java.util.Properties;        /**         * JDBC工具类 使用Durid连接池         */        public class JDBCUtils {            private static DataSource ds ;            static {                try {                    //1.加载配置文件                    Properties pro = new Properties();                    //使用ClassLoader加载配置文件，获取字节输入流                    InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);                    pro.load(is);                    //2.初始化连接池对象                    ds = DruidDataSourceFactory.createDataSource(pro);                } catch (IOException e) {                    e.printStackTrace();                } catch (Exception e) {                    e.printStackTrace();                }            }            /**             * 获取连接池对象             */            public static DataSource getDataSource(){                return ds;            }            /**             * 获取连接Connection对象             */            public static Connection getConnection() throws SQLException {                return  ds.getConnection();            }        }    5. 创建包cn.itcast.dao,创建类UserDao,提供login方法        package cn.itcast.dao;        import cn.itcast.domain.User;        import cn.itcast.util.JDBCUtils;        import org.springframework.dao.DataAccessException;        import org.springframework.jdbc.core.BeanPropertyRowMapper;        import org.springframework.jdbc.core.JdbcTemplate;        /**         * 操作数据库中User表的类         */        public class UserDao {            //声明JDBCTemplate对象共用            private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());            /**             * 登录方法             * @param loginUser 只有用户名和密码             * @return user包含用户全部数据,没有查询到，返回null             */            public User login(User loginUser){                try {                    //1.编写sql                    String sql = &quot;select * from user where username = ? and password = ?&quot;;                    //2.调用query方法                    User user = template.queryForObject(sql,                            new BeanPropertyRowMapper&lt;User&gt;(User.class),                            loginUser.getUsername(), loginUser.getPassword());                    return user;                } catch (DataAccessException e) {                    e.printStackTrace();//记录日志                    return null;                }            }        }    6. 编写cn.itcast.web.servlet.LoginServlet类        package cn.itcast.web.servlet;        import cn.itcast.dao.UserDao;        import cn.itcast.domain.User;        import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;        @WebServlet(&quot;/loginServlet&quot;)        public class LoginServlet extends HttpServlet {            @Override            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {                //1.设置编码                req.setCharacterEncoding(&quot;utf-8&quot;);                //2.获取请求参数                String username = req.getParameter(&quot;username&quot;);                String password = req.getParameter(&quot;password&quot;);                //3.封装user对象                User loginUser = new User();                loginUser.setUsername(username);                loginUser.setPassword(password);                //4.调用UserDao的login方法                UserDao dao = new UserDao();                User user = dao.login(loginUser);                //5.判断user                if(user == null){                    //登录失败                    req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp);                }else{                    //登录成功                    //存储数据                    req.setAttribute(&quot;user&quot;,user);                    //转发                    req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp);                }            }            @Override            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {                this.doGet(req,resp);            }        }    7. 编写FailServlet和SuccessServlet类        @WebServlet(&quot;/successServlet&quot;)        public class SuccessServlet extends HttpServlet {            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {                //获取request域中共享的user对象                User user = (User) request.getAttribute(&quot;user&quot;);                if(user != null){                    //给页面写一句话                    //设置编码                    response.setContentType(&quot;text/html;charset=utf-8&quot;);                    //输出                    response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;);                }            }                @WebServlet(&quot;/failServlet&quot;)        public class FailServlet extends HttpServlet {            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {                //给页面写一句话                //设置编码                response.setContentType(&quot;text/html;charset=utf-8&quot;);                //输出                response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;);            }            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {                this.doPost(request,response);            }        }    8. login.html中form表单的action路径的写法        * 虚拟目录+Servlet的资源路径    9. BeanUtils工具类，简化数据封装        * 用于封装JavaBean的        1. JavaBean：标准的Java类            1. 要求：                1. 类必须被public修饰                2. 必须提供空参的构造器                3. 成员变量必须使用private修饰                4. 提供公共setter和getter方法            2. 功能：封装数据        2. 概念：            成员变量：            属性：setter和getter方法截取后的产物                例如：getUsername() --&gt; Username--&gt; username        3. 方法：            1. setProperty()            2. getProperty()            3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛最多水的容器</title>
      <link href="/lihaoran0219.github.io/2020/04/18/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/lihaoran0219.github.io/2020/04/18/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><pre><code>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。</code></pre><p><img src="/lihaoran0219.github.io/2020/04/18/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/question.jpg" alt></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>双指针：定义两个指针，分别指向数组的头和尾能盛多少水取决于两条线的距离和两条线中的较低的那个高度所以我们每次让两个指针中高度较低的那一个往中间移动，直到两指针相遇</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;  <span class="comment">//头指针</span></span><br><span class="line">        <span class="keyword">int</span> tail = height.length - <span class="number">1</span>; <span class="comment">//尾指针</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tail - pre &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[pre], height[tail]) * (tail - pre));</span><br><span class="line">            <span class="keyword">if</span>(height[pre] &gt; height[tail])  <span class="comment">//每次让高度较小的移动</span></span><br><span class="line">                tail--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java File类</title>
      <link href="/lihaoran0219.github.io/2020/04/17/File%E7%B1%BB/"/>
      <url>/lihaoran0219.github.io/2020/04/17/File%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 构造方法</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;File(File parent, String child)</span><br></pre></td></tr></table></figure><p>从父抽象路径名和子路径名字符串创建新的 File实例。  </p><ul><li><p><code>File(String pathname)</code><br>通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</p><pre><code>参数pathname为路径名称（字符串形式）路径可以以文件结尾，也可以以文件夹结尾路径可以存在，也可以不存在</code></pre></li><li><p><code>File(String parent, String child)</code><br>从父路径名字符串和子路径名字符串创建新的 File实例。  </p><pre><code>把路径分为了两部分parent：父路径child: 子路径好处：父路径和子路径可以单独书写，使用起来很灵活</code></pre></li><li><p><code>File(URI uri)</code><br>通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。  </p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3></li><li><p><code>static String pathSeparator</code><br>与系统相关的路径分隔符字符，为方便起见，表示为字符串。 </p><pre><code>路径分隔符：    windows系统：;(分号)    linux系统： :(冒号)</code></pre></li><li><p><code>static char pathSeparatorChar</code><br>与系统相关的路径分隔符。  </p></li><li><p><code>static String separator</code><br>与系统相关的默认名称分隔符字符，以方便的方式表示为字符串。  </p><pre><code>名称分隔字符：    windows: \ (反斜杠)    linux： /（正斜杠）</code></pre></li><li><p><code>static char separatorChar</code><br>与系统相关的默认名称分隔符。  </p></li></ul><p>注意： 为了区分系统，尽量不要把路径写死，用这些静态变量表示</p><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><p>绝对路径： 是一个完整的路径（以盘符开始）</p></li><li><p>相对路径：是一个简化的路径（以当前项目的根目录开始）</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1.获取"></a>1.获取</h4></li><li><p><code>String getAbsolutePath()</code>: 返回此File对象的绝对路径</p></li><li><p><code>String  getPath()</code>: 返回此File对象的相对路径</p></li><li><p><code>String  getName()</code>: 返回此File对象表示的文件名称或目录名称</p></li><li><p><code>long  length()</code>：返回此File对象表示的文件的长度（字节为单位，文件夹没有大小的概念，如果路径不存在，返回0）</p><h4 id="2-判断"><a href="#2-判断" class="headerlink" title="2.判断"></a>2.判断</h4></li><li><p><code>boolean exists()</code>: 此File对象表示的文件或目录是否存在</p></li><li><p><code>boolean isDirectory()</code>: 此File对象表示的是否是目录</p></li><li><p><code>boolean isFile()</code>: 此File对象表示的是否为文件</p><h4 id="3-创建和删除"><a href="#3-创建和删除" class="headerlink" title="3.创建和删除"></a>3.创建和删除</h4></li><li><p><code>boolean createNewFile()</code>: 当且仅当具有该名称的文件不存在时，创建一个新的空文件</p><pre><code>1.此方法只能创建文件，不能创建文件夹2.创建文件的路径必须存在，否则会抛异常3.此方声明抛出了IOException，使用时必须处理异常</code></pre></li><li><p><code>boolean delete()</code>: 删除由此File对象表示的目录或文件</p></li><li><p><code>boolean mkdir()</code>: 创建由此File对象表示的目录（单级文件夹）</p></li><li><p><code>boolean mkdirs()</code>: 创建由此File对象表示的目录，包括任何必须但不存在的父目录（单极或多级文件夹）</p><h4 id="4-目录的遍历"><a href="#4-目录的遍历" class="headerlink" title="4.目录的遍历"></a>4.目录的遍历</h4></li><li><p><code>String[] list()</code>: 返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录。 </p></li><li><p><code>File[] listFiles()</code>: 返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。 </p><pre><code>1.路径不存在，会抛出空指针异常2.如果路径不是一个目录，也会抛出空指针异常3.隐藏文件或隐藏文件夹也可以遍历到</code></pre></li></ul><p>示例：递归打印多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 递归打印多级目录 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\Drivers"</span>);</span><br><span class="line">        getAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFiles</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())  <span class="comment">//如果是一个目录就继续遍历</span></span><br><span class="line">                getAllFiles(file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h3><p>遍历目录有这样两个方法：</p><figure class="highlight plain"><figcaption><span>listFiles(FileFilter filter)  ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;String[] list(FilenameFilter filter)</span><br></pre></td></tr></table></figure><p>其中方法的参数传递的就是过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：用来过滤文件</span><br><span class="line">接口中只有一个方法：&#96;&#96;&#96;boolean  accept(File pathname)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：用来过滤文件名称</span><br><span class="line">接口中只有一个方法：&#96;&#96;&#96;boolean  accept(File  dir,  String  name)</span><br></pre></td></tr></table></figure><p>注意：两个接口是没有实现类的，需要我们自己写实现类，重写accept方法，自定义过滤规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 过滤器 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\Drivers"</span>);</span><br><span class="line">        getAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFiles</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.FileFilter</span></span><br><span class="line">       <span class="comment">// File[] files = dir.listFiles(file -&gt; file.getName().endsWith("exe") || file.isDirectory());  //这里过滤掉不是以exe结尾的文件(因为后面还要递归遍历文件夹，所以文件夹也保留)</span></span><br><span class="line">        <span class="comment">//2.FilenameFilter</span></span><br><span class="line">        File[] files = dir.listFiles((d, name) -&gt; name.endsWith(<span class="string">"exe"</span>) || <span class="keyword">new</span> File(d, name).isDirectory());</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())  <span class="comment">//如果是一个目录就继续遍历</span></span><br><span class="line">                getAllFiles(file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/lihaoran0219.github.io/2020/04/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/lihaoran0219.github.io/2020/04/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Lambda 表达式（lambda expression）是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数</p><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。<br>&lt;–! more –&gt;</p><h3 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h3><p>我们在上一篇文章中讲到多线程时，常常用到Runnable接口定义线程的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03InnerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名内部类中，其实只有方法体才是关键所在，那我们可以不创建这个匿名内部类吗？</p><h3 id="Lambda初体验"><a href="#Lambda初体验" class="headerlink" title="Lambda初体验"></a>Lambda初体验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span>简化<span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就将代码简化了</p><ul><li><p>()表示run()方法的参数，此处没有参数‘</p></li><li><p>-&gt;表示将前面的参数传递给后面的代码</p></li><li><p>后面的输出语句即为业务逻辑代码</p><h3 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h3><p>Lambda表达式省去了面向对象的一些条条框框，格式由3部分组成：</p></li><li><p>一些参数</p></li><li><p>一个箭头</p></li><li><p>一段代码</p><figure class="highlight plain"><figcaption><span>参数名称) ->  &#123;代码&#125;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">没有参数括号中就没有内容，多个参数用逗号隔开</span><br><span class="line"></span><br><span class="line">再来举个例子，在排序的时候我们经常用Arrays.sort()方法传入一个比较器自定义比较规则，我么们也可以用Lambda表达式简写</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class demo02简化Comparator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arr &#x3D; &#123;98, -4, 2, 7, 11, 4, 8&#125;;</span><br><span class="line">        &#x2F;&#x2F;降序排序</span><br><span class="line">        Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                return o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;Lambda表达式</span><br><span class="line">        &#x2F;&#x2F;Arrays.sort(arr, (Integer o1, Integer o2) -&gt; o2 - o1);</span><br><span class="line">        Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);&#x2F;&#x2F;参数类型可以不写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以省略的内容：</p></li><li><p>参数列表的数据类型可以省略不写</p></li><li><p>如果参数只有一个，括号也可以不写</p></li><li><p>代码只有一行，{}， return 和分号 可以不写（要不写则都不写）</p><h3 id="Lambda使用前提"><a href="#Lambda使用前提" class="headerlink" title="Lambda使用前提"></a>Lambda使用前提</h3></li><li><p>必须具有接口，且接口中<strong>仅有一个抽象方法</strong></p></li><li><p>必须具有<strong>上下文推断</strong>（参数类型需和接口对应）</p><pre><code>备注：只有一个抽象方法的接口成为函数式接口</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/lihaoran0219.github.io/2020/04/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/lihaoran0219.github.io/2020/04/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1.并发与并行"></a>1.并发与并行</h3><ul><li>并发：指两个或多个事件在<strong>同一时间段内</strong>发生</li><li>并行：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）<br><img src="https://img-blog.csdnimg.cn/2020041612452826.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><a id="more"></a><h3 id="2-线程与进程"><a href="#2-线程与进程" class="headerlink" title="2.线程与进程"></a>2.线程与进程</h3></li><li>进程：指一个内存中运行的应用程序，每个进程都有一个独立的运行空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，有多个线程的程序成为多线程程序。<br><img src="https://img-blog.csdnimg.cn/20200416125412168.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>线程调度：</li><li>分时调度<br> 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间<ul><li>抢占式调度<br>优先让优先级高的线程使用CPU，如果线程的优先级相同，会随机选择一个线程（线程随机性），Java使用抢占式调度<h3 id="3-创建线程类"><a href="#3-创建线程类" class="headerlink" title="3.创建线程类"></a>3.创建线程类</h3>Java使用<code>Java.lang.Thread</code>类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序。<h4 id="创建多线程方法一"><a href="#创建多线程方法一" class="headerlink" title="创建多线程方法一"></a>创建多线程方法一</h4></li></ul></li><li>定义Thread类的子类，并重写该类的run()方法，该run方法中的内容就是线程需要完成的任务，因此把run()方法称为线程执行体</li><li>创建Thread子类的实例，即创建线程对象</li><li>调用线程对象的start()方法启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建多线程的第一种方式：创建Tread类的子类</span></span><br><span class="line"><span class="comment">1.定义一个类，继承Thread类</span></span><br><span class="line"><span class="comment">2.重写Thread类中的run()方法</span></span><br><span class="line"><span class="comment">3.创建子类的实例</span></span><br><span class="line"><span class="comment">4.调用对象的start()方法启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"run: "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main: "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h4><p>我们从以上程序的输出可以发现，程序是一会儿执行主线程，一会执行我们创建的线程，是随机的<br>两个线程一起抢夺CPU的执行时间，谁抢到了就执行</p><h4 id="多线程的内存"><a href="#多线程的内存" class="headerlink" title="多线程的内存"></a>多线程的内存</h4><p>每开启一个 线程，都会开辟一个独立的栈空间<br>每个线程之间独立，互不影响<br><img src="https://img-blog.csdnimg.cn/20200416135008431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="创建多线程方法二"><a href="#创建多线程方法二" class="headerlink" title="创建多线程方法二"></a>创建多线程方法二</h4><ul><li>创建一个类，实现Runnable接口</li><li>实现run()方法</li><li>创建Runnable接口的实现类对象<br>注：因为类没有继承Thread，所以该类的实例没有start()方法<br>Thread类 的构造方法允许传入一个Runnable接口的实现对象<br>要想开启线程需要用带Runnable参数的构造方法创建一个Thread对象，调用该对象的start()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建多线程的第二种方式：实现Runnable接口</span></span><br><span class="line"><span class="comment">1.定义一个类，继承Thread类</span></span><br><span class="line"><span class="comment">2.重写Thread类中的run()方法</span></span><br><span class="line"><span class="comment">3.创建子类的实例</span></span><br><span class="line"><span class="comment">4.调用对象的start()方法启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现多线程的两种方法区别"><a href="#实现多线程的两种方法区别" class="headerlink" title="实现多线程的两种方法区别"></a>实现多线程的两种方法区别</h4><p>如果一个类继承Threa，则不适合资源共享。但是如果实现了Runnable接口，则容易实现资源共享。<br>总结：<br><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p><pre><code>1.适合多个相同的程序代码去共享一个资源2.可以避免Java中单继承的局限性（继承了Thread类就不能继承别的类了）3.增加程序的健壮性，实现解耦操作，代码可以被多个先线程共享，代码和线程独立4.线程池只能放入Runnable或Callable类线程，不能直接放入继承Thread的类</code></pre><p>扩充：<br>    在Java中，每次执行程序 至少或启动两个线程，一个是main线程，一个是垃圾收集线程</p><h4 id="匿名内部类创建多线程"><a href="#匿名内部类创建多线程" class="headerlink" title="匿名内部类创建多线程"></a>匿名内部类创建多线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03InnerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4.线程安全"></a>4.线程安全</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>比如说电影院售票问题，一个售票窗口的时候不会出什么问题，但是多个窗口时就有可能同时出售同一张票，这显然是不应该的<br><img src="https://img-blog.csdnimg.cn/2020041615074529.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们来模拟一下三个窗口同时售票的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo04ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl r = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">/*3个线程模拟3个窗口*/</span></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200416174040314.png#pic_center" alt="在这里插入图片描述"><br>我们发现出现了重复卖票的情况，那么出现这种情况的原因是什么呢？<br>上文中说过，Java采用抢占式调度，谁抢到了CPU的执行时间谁就就执行<br>在线程0卖完第100张票还没来得及更新票的时候，线程1抢到了执行时间，线程1失去了执行权，线程1也来卖票，此时他认为100还没卖出去，继续卖，这就产生了上述情况。<br>这在现实生活中是不能够发生的。<br>那么我们如何避免产生这一类的问题呢？<br>其实我们只需要保证在一个线程在访问公共资源时，无论其是否失去了CPU的执行权，都让其他的线程无法访问公共资源<br>接下来就来讲讲如何实现</p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制<br>有3中方式完成同步操作：</p><pre><code>1.同步代码块2.同步方法3.锁机制</code></pre><p><strong>1.同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决线程安全问题方法一：使用同步代码块</span></span><br><span class="line"><span class="comment">模式：</span></span><br><span class="line"><span class="comment">synchronized(锁对象)&#123;</span></span><br><span class="line"><span class="comment">    可能出现线程安全问题的代码块</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">    1.通过代码块中的锁对象，可以使用任意的对象</span></span><br><span class="line"><span class="comment">    2.但是必须保证多个线程使用的锁对象是同一个</span></span><br><span class="line"><span class="comment">    3.锁对象的作用：</span></span><br><span class="line"><span class="comment">        把同步代码块锁住，只让一个线程在同步代码块中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo05ThreadSafe2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">//创建一个锁对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (obj)&#123;  <span class="comment">//同步代码块</span></span><br><span class="line">                   <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                       System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                       ticket--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl r = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步的原理：</strong><br>使用了一个锁对象<br>3个线程同时抢夺CPU执行权，谁抢到了谁执行run()方法进行卖票<br>t0抢到了，执行run()方法，遇到synchronized代码块，会检查是否有锁对象<br>发现有，就获取到锁对象，进入到同步代码块中<br>t1抢到了执行权，执行run()方法，遇到synchronized代码块，检查是否有锁对象<br>发现没有锁对象，就会进入阻塞状态，会一直等到t0线程归还锁对象，等t0执行完归还锁对象后t1才能进入同步代码块<br><strong>2.同步方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决线程安全问题方法一：使用同步方法</span></span><br><span class="line"><span class="comment">1.将访问了共享数据的代码抽取出来放到一个方法中</span></span><br><span class="line"><span class="comment">2.在方法上添加synchronized修饰符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo06ThreadSafe3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">//创建一个锁对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                pay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   定义一个同步方法</span></span><br><span class="line"><span class="comment">   同步方法的锁对象其实就是执行方法的实现类对象（this）</span></span><br><span class="line"><span class="comment">   注意：如果同步方法是静态的，那么锁对象是本类的class属性（class文件对象）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl r = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.Lock锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lock锁将获取锁和释放锁方法化</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;public void lock()&#96;&#96;&#96;: 加同步锁</span><br><span class="line">&#96;&#96;&#96;public void unlock()&#96;&#96;&#96;:释放同步锁</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">解决线程安全问题方法三：使用Lock锁</span><br><span class="line">java.util.concurrent.locks.reentrantLock 实现了lock接口</span><br><span class="line"></span><br><span class="line">1.创建reentrantLock类的对象</span><br><span class="line">2.在可能会出现线程安全的位置前调用Lock接口的lock()方法</span><br><span class="line">3.在可能会出现线程安全的位置后面调用Lock接口的unlock()方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class demo07ThreadSafe4 &#123;</span><br><span class="line">    static class RunnableImpl implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private int ticket &#x3D; 100;</span><br><span class="line">        Lock lock &#x3D; new ReentrantLock(); &#x2F;&#x2F;1.创建reentrantLock类的对象</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                lock.lock();&#x2F;&#x2F;2.在可能会出现线程安全的位置前调用Lock接口的lock()方法</span><br><span class="line">                try&#123;</span><br><span class="line">                    if (ticket &gt; 0) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;正在卖第&quot; + ticket + &quot;张票&quot;);</span><br><span class="line">                        ticket--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();&#x2F;&#x2F;3.在可能会出现线程安全的位置后面调用Lock接口的unlock()方法</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RunnableImpl r &#x3D; new RunnableImpl();</span><br><span class="line">        Thread t0 &#x3D; new Thread(r);</span><br><span class="line">        Thread t1 &#x3D; new Thread(r);</span><br><span class="line">        Thread t2 &#x3D; new Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-线程的状态"><a href="#5-线程的状态" class="headerlink" title="5.线程的状态"></a>5.线程的状态</h3><p><img src="https://img-blog.csdnimg.cn/20200416194353821.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p><strong>1.线程间通信</strong></p><p><strong>概念</strong>：多个线程在处理同一个资源，但处理的动作不同</p><p>比如线程1生产包子，线程2吃包子，包子就是资源，两个线程都是处理包子，但任务不同，两个线程就存在线程通信问题</p><p><strong>为什么要处理线程间的通信问题</strong></p><p>多个线程并发执行时，在默认情况下CPU是随机切换线程的，当我们需要多个线程共同来完成一件任务，并且我们需要他们按照规律执行时，就需要进行协调通信。</p><p><strong>如何实现线程间通信</strong><br>等待唤醒机制</p><p><strong>2.等待唤醒机制</strong></p><p><strong>什么是等待唤醒机制</strong><br>即多线程间的<strong>协作</strong>机制</p><p>还是以包子为例：<br><img src="https://img-blog.csdnimg.cn/20200416204851349.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>等待唤醒中的方法：</p><p>1.wait() : 线程不再活动，不再参与调度，进入wait set，这时线程的状态为        WAITING。他还要等着别的线程执行<strong>notify</strong>，在这个对象上等待的线程从wait set中释放出来，进入调度队列<br>2.notify() : 选取所通知对象wait set 中的一个线程释放<br>3.notifyAll() : 释放所通知对象wait set 中的所有线程</p><p>我们还是以包子铺为例实现一下生产包子和吃包子两个线程间的通信：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo09</span>等待唤醒案例2 </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    包子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Baozi</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String p; <span class="comment">//包子皮</span></span><br><span class="line">        String x;<span class="comment">//包子馅</span></span><br><span class="line">        Boolean status = <span class="keyword">false</span>;<span class="comment">//包子的状态</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    包子铺类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Baozi b; <span class="comment">//包子当作锁对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Shop</span><span class="params">(Baozi b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b.status)&#123;  <span class="comment">//此时有包子</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            b.wait(); <span class="comment">//包子铺进入等待状态</span></span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*被唤醒之后*/</span></span><br><span class="line">                    <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//生产薄皮三鲜馅的包子</span></span><br><span class="line">                        b.p = <span class="string">"薄皮"</span>;</span><br><span class="line">                        b.x = <span class="string">"三鲜"</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//生产冰皮牛肉大葱馅包子</span></span><br><span class="line">                        b.p = <span class="string">"冰皮"</span>;</span><br><span class="line">                        b.x = <span class="string">"牛肉大葱"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(<span class="string">"包子铺正在生产"</span> + b.p + b.x + <span class="string">"包子"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);<span class="comment">//生产包子需要3秒</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    b.status = <span class="keyword">true</span>;  <span class="comment">//修改包子的状态</span></span><br><span class="line">                    b.notify(); <span class="comment">//唤醒吃货线程</span></span><br><span class="line">                    System.out.println(b.p + b.x + <span class="string">"包子生产好了！！！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    吃货类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Eat</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Baozi b; <span class="comment">//包子当作锁对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Eat</span><span class="params">(Baozi b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!b.status)&#123; <span class="comment">//没有包子</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            b.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*被唤醒之后*/</span></span><br><span class="line">                    System.out.println(<span class="string">"吃货正在吃"</span> +b.p + b.x + <span class="string">"包子"</span>);</span><br><span class="line">                    b.status = <span class="keyword">false</span>; <span class="comment">//包子吃完了，修改包子的状态</span></span><br><span class="line">                    b.notify(); <span class="comment">//唤醒包子铺线程</span></span><br><span class="line">                    System.out.println(<span class="string">"吃货已经把"</span> +b.p + b.x + <span class="string">"包子吃完了，包子铺开始生产"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Baozi b = <span class="keyword">new</span> Baozi(); <span class="comment">//创建包子对象</span></span><br><span class="line">        <span class="keyword">new</span> Shop(b).start();<span class="comment">//开启包子铺线程</span></span><br><span class="line">        <span class="keyword">new</span> Eat(b).start();<span class="comment">//开启吃货线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h3><p>当并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率<br>那么有没有一种方法可以使线程复用，不必再每次创建线程呢？Java中可以使用线程池达到这样的效果。</p><p>线程池实际上就是一个存放线程的集合（ArrayList, LinkedList等）<br>在JDK1.5以后内置了线程池</p><p>Java里面线程池的顶级接口时<code>java.util.concurrent.Executors</code>，该类是线程池的工厂类<br>Executor类中创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThread)</code><br>返回线程池对象，可以指定池中线程的数量</li><li><code>public  future&lt;?&gt; submit(Runnable task)</code><br>  获取线程池中某一线程对象，并执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo10ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用线程池工厂类Executors的静态方法newFixedThreadPool生成一个指定线程数量的线程池</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//2.创建一个类，实现Runna接口，重写run()方法</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"已开始"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.调用 ExecutorService中的submit()方法，传递线程任务，开启线程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> RunnableImpl());  <span class="comment">//线程池会一直开启，使用完的线程会自动归还给线程池，可重复使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="/lihaoran0219.github.io/2020/04/15/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/lihaoran0219.github.io/2020/04/15/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Alt + Enter</td><td>导入包，自动修正代码</td></tr><tr><td>Ctrl + Y</td><td>删除光标所在行</td></tr><tr><td>Ctrl + D</td><td>复制光标所在行</td></tr><tr><td>Ctrl + Alt + L</td><td>格式化代码</td></tr><tr><td>Ctrl + /</td><td>单行注释，再按取消注释</td></tr><tr><td>Ctrl + Shift +  /</td><td>选中代码注释，再按取消注释</td></tr><tr><td>Alt + Ins</td><td>自动生成代码，toString,get,set等方法，新建文件等</td></tr><tr><td>Alt + Shift + 上下箭头</td><td>移动当前代码行</td></tr><tr><td>Ctrl + Alt + T</td><td>Surround With…</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有多少小于当前数字的数字</title>
      <link href="/lihaoran0219.github.io/2020/04/14/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/lihaoran0219.github.io/2020/04/14/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。</p><p>以数组形式返回答案。</p><p>示例 1：</p><pre><code>输入：nums = [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]=1 不存在比它小的数字。对于 nums[2]=2 存在一个比它小的数字：（1）。 对于 nums[3]=2 存在一个比它小的数字：（1）。 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</code></pre><p>示例 2：</p><pre><code>输入：nums = [6,5,4,8]输出：[2,1,0,3]</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7]输出：[0,0,0,0]</code></pre><p>提示：</p><pre><code>2 &lt;= nums.length &lt;= 5000 &lt;= nums[i] &lt;= 100</code></pre> <a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一 暴力法"></a>方法一 暴力法</h4><p>定一个数，然后从后面找比它小的数，找到则计数器加一（时间复杂度O(N^2)）</p><h4 id="方法二-排序"><a href="#方法二-排序" class="headerlink" title="方法二  排序"></a>方法二  排序</h4><p>将数组排好序，然后等于nums[i]的第一个元素的下标即为比它小的元素个数</p><p>这里我用了线性查找和二分查找两种方法查找第一个等于nums[i]的元素</p><h3 id="方法三-计数-前缀和数组"><a href="#方法三-计数-前缀和数组" class="headerlink" title="方法三 计数 + 前缀和数组"></a>方法三 计数 + 前缀和数组</h3><pre><code>这种方法类似于计数排序因为元素的范围为0--100，所以我们定义一个长度为101的数组bucket遍历一遍数组，元素转下标，记录出现的次数然后我们将bucket数组转化为前缀和数组（即bucket[i] = bucket[i] + bucket[i - 1]）这样一来bucket[i]表示小于等于i的元素个数所以bucket[i - 1]表示小于i的元素个数</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = nums.clone();</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = indexOf(temp, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//线性查找最左边的target下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = nums.clone();</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = indexOf(temp, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="comment">//桶用来记录每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) </span><br><span class="line">            bucket[num]++;</span><br><span class="line">        <span class="comment">//将桶数组变成前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">            bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时bucket[i]表示小于等于i的数的个数</span></span><br><span class="line">        <span class="comment">//所以bucket[i - 1]表示小于i的数的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = nums[i] == <span class="number">0</span> ? <span class="number">0</span> : bucket[nums[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表加法</title>
      <link href="/lihaoran0219.github.io/2020/04/14/%E9%93%BE%E8%A1%A8%E5%8A%A0%E6%B3%95/"/>
      <url>/lihaoran0219.github.io/2020/04/14/%E9%93%BE%E8%A1%A8%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：</p><pre><code>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre>  <a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>问题的关键在于链表的顺序和加法的顺序相反，我们要实现加法就要从链表的尾部开始</p><p>先遍历到链表尾部再相加的办法的办法真是太过于朴素了</p><p>其实对于逆序这一类问题我们应该首先想到的就是栈，利用栈很容易就将链表中的元素倒过来了</p><pre><code>1.遍历两个链表，将元素入栈2.依次从两个栈中弹出栈顶元素相加3.每一位上的数字应该是加完的结果对10取余加上进位4.用头插法创建链表存储结果5.保存进位</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode p = l1;</span><br><span class="line">        ListNode q = l2;</span><br><span class="line">        <span class="comment">/*将链表元素用栈保存*/</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.push(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.push(q.val);</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*分别弹出两个栈的栈顶元素相加*/</span></span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty() ||  carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += s1.isEmpty() ? <span class="number">0</span> : s1.pop();</span><br><span class="line">            sum += s2.isEmpty() ? <span class="number">0</span> : s2.pop();</span><br><span class="line">            <span class="comment">/*头插法添加链表结点*/</span></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = res;</span><br><span class="line">            res = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;  <span class="comment">//存储进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>航班预定统计</title>
      <link href="/lihaoran0219.github.io/2020/04/09/%E8%88%AA%E7%8F%AD%E9%A2%84%E5%AE%9A%E7%BB%9F%E8%AE%A1/"/>
      <url>/lihaoran0219.github.io/2020/04/09/%E8%88%AA%E7%8F%AD%E9%A2%84%E5%AE%9A%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。</p><p>请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。</p><p>示例：</p><pre><code>输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5输出：[10,55,45,25,25]</code></pre><p>提示：</p><pre><code>1 &lt;= bookings.length &lt;= 200001 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 200001 &lt;= bookings[i][2] &lt;= 10000</code></pre> <a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1.暴力法"></a>1.暴力法</h4><p>外层循环遍历bookings数组</p><p>内层循环从i到j，转下标用数组rec记录每个航班的预定数</p><p>如[2, 5, 25]:</p><pre><code>则rec[2] += 25, rec[3] += 25, rec[4] += 25, rec[5] += 25</code></pre><p>####2.差分法</p><p>解法1每次都要从i到j遍历一次，我们可以进行一下优化</p><p>其实从i到j,每一个都加上k，这不就是等差数组嘛</p><p>我们只需遍历一遍bookings,用一个数组记录公差d,最后等差公式an = a(n - 1) + d即可</p><p>举个栗子：</p><p>假设d[0] = 0,我们从d[1]开始</p><p>[1, 2, 10]</p><pre><code>航班1预定了10，则和d[0]的公差为10，d[1] = 10航班2预定了10，则比航班3多10，即2和3的公差为-10，d[3] = -10</code></pre><p>[2, 3, 20]</p><pre><code>航班2和航班3预定了20航班2比航班1多了20，则1和2的公差为20， d[2] = 20航班3比航班4多了20，即3和4的公差为-20，d[4] = -20</code></pre><p>[2, 5, 25]</p><pre><code>航班2， 3， 4， 5都预定了25航班2又比航班1多了25，则公差变成了原来的20再加上25，即d[2] += 25 = 45推算到此结束，因为2，3，4，5都加了25，他们之间不会再拉开差距</code></pre><p>至此，数组d = [0, 10, 45, -10, -20, 0]</p><p>根据等差数列通项公式ans = [10, 55, 45, 25, 25]</p><p>总结一下就是：</p><pre><code>遍历到[i, j, k]时，d[i] += k, d[j + 1] -= k 最后再还原</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   暴力法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : bookings)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = arr[<span class="number">0</span>]; i &lt;= arr[<span class="number">1</span>]; i++)</span><br><span class="line">                ans[i - <span class="number">1</span>] += arr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    差分法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//d[i]表示公差，即和前一个航班的的预定数差多少</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : bookings)&#123;</span><br><span class="line">            d[arr[<span class="number">0</span>] - <span class="number">1</span>] += arr[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">1</span>] &lt; n)</span><br><span class="line">                d[arr[<span class="number">1</span>]] -= arr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原地旋转矩阵</title>
      <link href="/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><p>不占用额外内存空间能否做到？</p><p>示例 1:</p><pre><code>给定 matrix = [  [1,2,3],  [4,5,6],  [7,8,9]],原地旋转输入矩阵，使其变为:[  [7,4,1],  [8,5,2],  [9,6,3]]</code></pre><p>示例 2:</p><pre><code>给定 matrix =[  [ 5, 1, 9,11],  [ 2, 4, 8,10],  [13, 3, 6, 7],  [15,14,12,16]], 原地旋转输入矩阵，使其变为:[  [15,13, 2, 5],  [14, 3, 4, 1],  [12, 6, 8, 9],  [16, 7,10,11]]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目意思很简单，就是将矩阵顺时针旋转90°</p><p>这道题如果可以换成用辅助空间做那将绝杀，可是换不得</p><p>如果要原地修改的话我们只要找到规律也是很简单的</p><p>拿示例2举个栗子<br><img src="/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/matrix.png" alt></p><p>根据上图，我们可以看出，旋转90°即将每一行竖过来</p><p>即一个数原来在哪一列，旋转后就在哪一行，原来在哪一行，旋转后就在（总列数 - 原来的行数 - 1） 这一行</p><p>如原来的第3行第1列的14，旋转后到了第1行第0列</p><p>总结一下公式就是：arr[j][N - i - 1] = arr[i][j]</p><p>根据这个公式，我们就可以获取所有数字旋转后的位置</p><p>然而因为要原地，所以直接枚举的话原来的数据会被覆盖掉，所以换一个枚举策略</p><p>我们将数组看作n层，如示例2可看作两层<br><img src="/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/exp.png" alt></p><pre><code>我们从5开始，5要换到11的位置，在换之前先保存一下原来位置的数据（下同）然后从11开始，11换到16的位置然后从16开始，16换到15的位置然后从15开始，15换到5原来的位置这样一圈下来，就变成了下图所示</code></pre><p> <img src="/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/exp1.png" alt></p><p>我们发现外面这一层只剩4个没有换位置，我们只需再从（1，0）的2开始再来一圈就可以将外层全部旋转</p><p>外层旋转完毕之后用同样的操作旋转内圈</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//j为每一层的左上角第一个元素的纵坐标</span></span><br><span class="line">        <span class="keyword">int</span> temp = n;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt;=  <span class="number">2</span>)&#123;  <span class="comment">//以层为单位来旋转</span></span><br><span class="line">           cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt; j + temp - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                update(matrix, i, j, matrix[i][j]);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp  -= <span class="number">2</span>;<span class="comment">//处理完一层后，下一层的行数会减2</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对每一个位置（i, j）,我们将他换到旋转后的位置，再将旋转到的位置的原来的元素旋转，重复4次即为一圈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">4</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = j;</span><br><span class="line">        <span class="keyword">int</span> col = n - i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = matrix[row][col]; <span class="comment">//保存原来位置的值，避免被覆盖掉</span></span><br><span class="line">        matrix[row][col] = value; </span><br><span class="line">        cnt++;</span><br><span class="line">        update(matrix, row, col, temp);<span class="comment">//旋转下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短编辑距离问题</title>
      <link href="/lihaoran0219.github.io/2020/04/06/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/"/>
      <url>/lihaoran0219.github.io/2020/04/06/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><pre><code>插入一个字符删除一个字符替换一个字符</code></pre><p>示例 1：</p><pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;)</code></pre><p>示例 2：</p><pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;)&lt;!-- more --&gt;</code></pre><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>四月的LeetCode每日一题真的是太难了，快要打不动卡啦！！！</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看完题，我们大致也就知道了编辑距离的意思，就是一个字符串转化为另一个字符串需要的步骤</p><p>这道题要求最少操作次数（最短编辑距离），通过最少和只求次数我们基本可以判断使用动态规划</p><p>这里先放出状态转移方程，之后再解释</p><pre><code>dp[i][j] = k表示str1的前i个字符转化为str2的前j个字符所用的最少操作次数为kdp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1特殊的，如果i,j指向的字符相同，则dp[i][j] = dp[i - 1][j - 1]</code></pre><p>我们来举个例子：</p><p>针对题中的示例1，dp矩阵初始为下图：<br><img src="/lihaoran0219.github.io/2020/04/06/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/init.png" alt><br>当i为0时，dp[i][j] = j</p><p>当j为0时，dp[i][j] = i</p><p>这是显而易见的，因为对于空串来说，转化为另一个字符串只需插入相应的字符即可</p><p>我们来试着计算一下dp[2]这一行：</p><p>dp[2][0]即ho –&gt; 空，为2（删除两个字符）</p><p>dp[2][1]即ho –&gt; r</p><pre><code>我们可选的有插入，删除，替换操作1.插入：在ho --&gt; 空串的基础上我们再插入一个r即可转化为r,即dp[2][1] = dp[2][0]+12.删除：在h --&gt; r的基础上我们再删除o即可转化为r，即dp[2][1] = dp[1][1]+13.替换：在h --&gt; 空串的基础上我们只需将o替换为r即可转化为r,即dp[2][1]=dp[1][0]+1我们选择三种方式中操作数最小的即是dp[2][1]的值</code></pre><p>dp[2][2]即ho –&gt; ros</p><pre><code>我们可选的有插入，删除，替换操作1.插入：在ho --&gt; ro的基础上我们再插入一个s即可转化为ros,即dp[2]2] = dp[2][1]+12.删除：在h --&gt;ros的基础上我们再删除o即可转化为ros，即dp[2][2] = dp[1][2]+13.替换：在h --&gt; ro的基础上我们只需将o替换为s即可转化为ros,即dp[2][2]=dp[1][1]+1我们选择三种方式中操作数最小的即是dp[2][2]的值</code></pre><p>  根据以上方法，我们将dp数组填满，最后返回数组的最后一个值即是题目的答案</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">        <span class="comment">//dp[i][j]表示word1的前i个字符转换为word2的前j个字符的最短编辑距离（最少操作数）</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//i = 0，即word1的前0个字符（空串--&gt; word2的前 j个字符），最短编辑距离即为j的取值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 + <span class="number">1</span>; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="comment">//j = 0,即word2的前0个字符（word1的前 i个字符 --&gt;空串），最短距离即为i的取值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 + <span class="number">1</span>; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1 + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2 + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//两个字符相等，在上一步的基础上无需操作，dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line">                 <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//否则在插入，删除，替换三种操作中选一个操作数最小的,然后加1</span></span><br><span class="line">                <span class="comment">//插入：dp[i][j - 1]</span></span><br><span class="line">                <span class="comment">//删除：dp[i - 1][j]</span></span><br><span class="line">                <span class="comment">//替换：dp[i - 1][j - 1]</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j]),dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表倒数第K结点（快慢指针）</title>
      <link href="/lihaoran0219.github.io/2020/04/04/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E7%BB%93%E7%82%B9%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/"/>
      <url>/lihaoran0219.github.io/2020/04/04/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E7%BB%93%E7%82%B9%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p>示例：</p><pre><code>输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2输出： 4</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针是解决这类问题的经典算法，如求链表的中间节点等问题，都可以用到这个思想</p><ul><li>我们定义两个指针fast和slow，初始指向链表的头结点</li><li>先让快指针fast先走k步，然后再让两指针同步走</li><li>直到快指针为空（走出了链表），慢指针slow所在的位置即是链表的倒数第k个结点<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;  <span class="comment">//快指针先走k步</span></span><br><span class="line">                <span class="keyword">if</span>(fast == <span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;<span class="comment">//两指针同步走，直到快指针为空</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水问题</title>
      <link href="/lihaoran0219.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
      <url>/lihaoran0219.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/lihaoran0219.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/rainwatertrap.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p>示例:</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre> <a id="more"></a>  <h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题用单调栈解决</p><p><img src="/lihaoran0219.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/example.png" alt></p><p>说到栈，我们肯定会想到括号匹配了。<br>我们仔细观察蓝色的部分，可以和括号匹配类比下。<br>每次匹配出一对括号（找到对应的两个柱子），就计算两个柱子之间的水。</p><p>我们用栈保存每个柱子。</p><p>当遍历柱子的高度的时候，如果当前高度小于栈顶的柱子高度，说明这里出现凹陷，可以接雨水，我们将该柱子下标入栈。</p><p>如果当前高度大于栈顶的墙的高度，说明凹陷在这里停止，出现了高低高的组合，我们可以计算两个高柱之间的雨水量，算完之后，就把当前柱子继续入栈。</p><p>总体的原则就是，</p><pre><code>1.当前柱子高度小于栈顶柱子高度，说明有凹陷，可接雨水，入栈当前柱子的下标2.当前柱子高度大于栈顶柱子高度，说明凹陷到此结束，计算此凹陷能装多雨水，计算完后将此柱子下标入栈3.计算过程：    接雨水数量 = 底边长 * 高    形如高低高的三个柱子才能接到水，    那么底边长 = 两个高柱子的下标差减1（表现在代码中则是弹出栈顶，当前柱子和新栈顶比较）    高 = 两高柱子中取较低的柱子的高度，然后减去中间低柱子的高度    重复计算，直至栈顶柱子的高度大于当前柱子高度</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//维护一个单调栈 </span></span><br><span class="line">            s.push(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(height[i] &lt; height[s.peek()])&#123;<span class="comment">//当前柱子高度小于栈顶柱子高度，直接入栈</span></span><br><span class="line">                    s.push(i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(!s.isEmpty() &amp;&amp; height[i] &gt; height[s.peek()])&#123;<span class="comment">//当前柱子高度大于栈顶柱子高度,计算</span></span><br><span class="line">                    <span class="keyword">int</span> temp = height[s.pop()];<span class="comment">//弹出栈顶元素并记录栈顶柱子高度(即中间低柱子的高度)</span></span><br><span class="line">                    <span class="keyword">if</span>(s.isEmpty())<span class="keyword">break</span>;</span><br><span class="line">                    res += ((i - s.peek() - <span class="number">1</span>) * (Math.min(height[s.peek()], height[i]) - temp));</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(i);<span class="comment">//计算完后将当前柱子入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命游戏（复合标志的使用）</title>
      <link href="/lihaoran0219.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
      <url>/lihaoran0219.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。</p><p>每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。</p><p>每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><pre><code>（1）如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；（2）如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；（3）如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；（4）如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</code></pre><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>示例：</p><pre><code>输入： [  [0,1,0],  [0,0,1],  [1,1,1],  [0,0,0]]输出：[  [0,0,0],  [1,0,1],  [0,1,1],  [0,1,0]]</code></pre><p>进阶：</p><pre><code>* 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。* 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果用一个新数组记录每个细胞的下一状态，那么这道题很简单，只需模拟过程即可</p><p>这里要求原地修改数组，我们可以先遍历一遍数组，根据四条规则用复合标志标记每一个细胞的状态</p><p>复合标志可以记录每个细胞的原始状态和一次更新后的状态</p><p>我们通过四条生存定律举个例子：</p><pre><code>（1）如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；        活细胞 --&gt; 死细胞   标记为-1（2）如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；        活细胞 --&gt; 活细胞 仍为1（3）如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；        活细胞 --&gt; 死细胞  标记为-1（4）如果死细胞周围正好有三个活细胞，则该位置死细胞复活；        死细胞 --&gt; 活细胞  标记为2</code></pre><p>状态更新完后活细胞被标记为1或2，死细胞被标记为-1</p><p>然后我们就可以再遍历一遍数组将细胞的状态恢复为0或1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> live = <span class="number">0</span>; <span class="comment">//记录周围的活细胞数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)&#123;<span class="comment">//在细胞周围的八个方向找活细胞</span></span><br><span class="line">                    <span class="keyword">int</span> newX = i + dx[k];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(newX &lt; <span class="number">0</span> || newX &gt;= board.length || newY &lt; <span class="number">0</span> || newY &gt;= board[<span class="number">0</span>].length)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(board[newX][newY] == <span class="number">1</span> || board[newX][newY] == -<span class="number">1</span>)<span class="comment">//原始状态是活细胞被标记为了1或-1</span></span><br><span class="line">                        live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((live &lt; <span class="number">2</span> || live &gt; <span class="number">3</span>) &amp;&amp; board[i][j] == <span class="number">1</span>)board[i][j] = -<span class="number">1</span>;<span class="comment">//活细胞--&gt;死细胞</span></span><br><span class="line">                <span class="keyword">if</span>(live == <span class="number">3</span> &amp;&amp; board[i][j] == <span class="number">0</span>)board[i][j] = <span class="number">2</span>; <span class="comment">//死细胞--&gt;活细胞</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*恢复状态为0或1*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == -<span class="number">1</span>)</span><br><span class="line">                    board[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> || board[i][j] == <span class="number">2</span>)</span><br><span class="line">                    board[i][j] = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环问题</title>
      <link href="/lihaoran0219.github.io/2020/03/30/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/lihaoran0219.github.io/2020/03/30/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>示例 1：</p><pre><code>输入: n = 5, m = 3输出: 3</code></pre><p>示例 2：</p><pre><code>输入: n = 10, m = 17输出: 2</code></pre><p>限制：</p><pre><code>1 &lt;= n &lt;= 10^51 &lt;= m &lt;= 10^6</code></pre><p>题目出自LeetCode  面试题62. 圆圈中最后剩下的数字</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。</p><p>那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</p><p>由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。</p><p>当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。</p><p>因此有 f(n, m) = (m % n + x) % n = (m + x) % n。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(lastRemaining3(<span class="number">55</span>, <span class="number">107</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法一：ArrayList代替环形链表进行模拟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (cur + m - <span class="number">1</span>) % list.size();</span><br><span class="line">            list.remove(index);</span><br><span class="line">            cur = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法二：递归</span></span><br><span class="line"><span class="comment">    将问题分解：</span></span><br><span class="line"><span class="comment">    首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。</span></span><br><span class="line"><span class="comment">    那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</span></span><br><span class="line"><span class="comment">    由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。</span></span><br><span class="line"><span class="comment">    当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。</span></span><br><span class="line"><span class="comment">    因此有 f(n - 1, m) = (m % n + x) % n = (m + x) % n。</span></span><br><span class="line"><span class="comment">    我们递归计算 f(n, m), f(n - 1, m), f(n - 2, m), ... 直到递归的终点 f(1, m)。当序列长度为 1 时，一定会留下唯一的那个元素，它的编号为 0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastRemaining2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = lastRemaining2(n - <span class="number">1</span>, m);<span class="comment">//上一次删除的位置</span></span><br><span class="line">        <span class="keyword">return</span> (x + m) % n; <span class="comment">//在上次删除的位置再走m步</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法三：将递归改为迭代形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastRemaining3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res = (res + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词的压缩编码（Trie字典树的应用）</title>
      <link href="/lihaoran0219.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%EF%BC%88Trie%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/"/>
      <url>/lihaoran0219.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%EF%BC%88Trie%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p><p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p><p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p><p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><p>示例：</p><pre><code>输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]输出: 10说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。</code></pre><p>提示：</p><pre><code>1 &lt;= words.length &lt;= 20001 &lt;= words[i].length &lt;= 7每个单词都是小写字母 。</code></pre><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根据示例，将”time”, “me”, “bell”三个单词变成了”time#bell#”</p><p>我们可以发现indexes = [0, 2, 5]是3个单词在压缩后的字符串中的起始索引</p><p>那么我们可以判断一个字符串是否是另一个字符串的后缀（如me是time的后缀，则被舍弃）</p><p>这样的话很容易想到了字典树（前缀树），这里先来看看：</p><p>假设有8个单词”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”</p><p>他们在前缀树中是这样存储的：</p><p><img src="/lihaoran0219.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%EF%BC%88Trie%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/Trie.png" alt="图片来自LettCode"></p><p>前缀树的结点定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> value;</span><br><span class="line">            TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>插入操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (cur.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据字典树的特性，我们可以将每一个字符串逆序存入树中</p><p>逆序是为了判断掉当前单词是否是某一个单词的后缀</p><p>还需要注意：插入时字符串长度长的要先插入</p><p>如time和me,如果先插入me，那么两个单词都可完成插入操作，无法正确判断</p><p>基于此，只需要对插入操作的代码稍作改动即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">        TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            TrieNode cur = root;</span><br><span class="line">            <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标记是否插入字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = chars.length - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//字符串逆序存储，这样的目的是如果某个单词是别的单词的后缀，那么就不会执行插入操作</span></span><br><span class="line">                <span class="keyword">int</span> index = chars[i] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.children[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cur.children[index] = <span class="keyword">new</span> TrieNode(chars[i]);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.children[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag ? word.length() + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> value;</span><br><span class="line">            TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">int</span> sumLen = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(words, (s1, s2) -&gt; s2.length() - s1.length());<span class="comment">//根据字符串的长度降序排序（这里用jdk8的lambda表达式）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            sumLen += root.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>523.连续的子数组和</title>
      <link href="/lihaoran0219.github.io/2020/03/26/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"/>
      <url>/lihaoran0219.github.io/2020/03/26/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p>示例 1:</p><pre><code>输入: [23,2,4,6,7], k = 6输出: True解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。</code></pre><p>示例 2:</p><pre><code>输入: [23,2,6,4,7], k = 6输出: True解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</code></pre><p>说明:</p><p>数组的长度不会超过10,000。</p><p>你可以认为所有数字总和在 32 位有符号整数范围内。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一-前缀和数组（O-N-2-）"><a href="#方法一-前缀和数组（O-N-2-）" class="headerlink" title="方法一 前缀和数组（O(N^2)）"></a>方法一 前缀和数组（O(N^2)）</h4><pre><code>pre数组存放原数组的前缀和，即pre[i]表示原数组的前i个元素的和枚举每一个子数组（元素个数大于1），判断和是否是k的倍数其中nums[i] ~ nums[j]这一子数组的和为pre[j] - pre[i - 1]</code></pre><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;<span class="comment">//修改原数组化为前缀和数组，即nums[i]表示前i位之和</span></span><br><span class="line">               nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">if</span>(check(nums[i], k))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123; <span class="comment">//枚举nums[i] ~ nums[j]之和，判断是否是k的倍数</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; nums.length; j++)&#123; <span class="comment">//第i位到第j位之和在前缀和数组中为nums[j] - nums[i - 1];</span></span><br><span class="line">                   <span class="keyword">if</span>(check(nums[j] - nums[i], k))</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//判断num是否为k的倍数</span></span><br><span class="line">           <span class="keyword">return</span> k == <span class="number">0</span> ? num == k : num % k == <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-HashMap优化的前缀和数组-O-N"><a href="#方法二-HashMap优化的前缀和数组-O-N" class="headerlink" title="方法二 HashMap优化的前缀和数组(O(N))"></a>方法二 HashMap优化的前缀和数组(O(N))</h4><pre><code>和方法一类似，方法二不同在于用HashMap存储前缀和，并且每次存储时都将结果对k取余结果以 (前i位之和sum % k -- i)键值对的形式存储遍历数组，如果key不存在，则加入哈希表，如果存在，说明存在子数组和为k的倍数原理：     因为每一个key都是前缀和对k取余的结果     所以当遇到相同的key时，说明之间的差值一定是k的倍数,即：        若          m % k = a          (m + n) % k = a        则 n % k = 0     由此可得出：        前j项之和对k取余的结果 == 前i项之和对k取余的结果（j &gt; i)时        nums[i + 1] ~ nums[j]这一段子数组的和是k的倍数（j - i &gt; 1）</code></pre><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       解法2：HashMap优化前缀和数组</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           Map&lt;Integer, Integer&gt;  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           map.put(<span class="number">0</span>, -<span class="number">1</span>);<span class="comment">//防止出现&#123;0，0&#125;，k=0的情况</span></span><br><span class="line">           <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">               sum += nums[i];</span><br><span class="line">               <span class="keyword">if</span>(k != <span class="number">0</span>)</span><br><span class="line">                   sum %= k;  <span class="comment">//每次存前i位的和对k的余数</span></span><br><span class="line">               <span class="keyword">if</span>(!map.containsKey(sum))</span><br><span class="line">                   map.put(sum, i);</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(i - map.get(sum) &gt; <span class="number">1</span>)  <span class="comment">//必须是两个及以上元素之和</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>779.第K个语法符号</title>
      <link href="/lihaoran0219.github.io/2020/03/23/779.%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
      <url>/lihaoran0219.github.io/2020/03/23/779.%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p><p>给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）</p><p>例子:</p><pre><code>输入: N = 1, K = 1输出: 0输入: N = 2, K = 1输出: 0输入: N = 2, K = 2输出: 1输入: N = 4, K = 5输出: 1解释:第一行: 0第二行: 01第三行: 0110第四行: 01101001</code></pre><p>注意：</p><p>N 的范围 [1, 30].<br>K 的范围 [1, 2^(N-1)].</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以多写几行数据，不难发现规律：</p><p>第N行有 2^(N-1) 个字符，且前一半和上一行的字符相同，后一半是对前一半的每个字符取反（0变1，1变0）</p><p>这样我们可以对要找的某一个字符追根溯源，找到他是从哪个字符变化而来的，这一过程用递归或迭代很容易完成</p><p>例如：</p><p>第5行的数据为： 01101001 10010110 </p><p>若N = 5, K = 14</p><p>解答过程：</p><pre><code>N = 5:    K = 14 &gt; 8,在后一半，是由前一半的第6个数取反而来,而第6个数又是由第第4行得来N = 4: K = 6 &gt; 4,在后一半，是由前一半的第2个数取反而来，而第2个数又是由第3行得来N = 3: K = 2 &lt;= 2,在前一半，是由第2行的第2个数得来N = 2: K = 2 &gt; 1,在后一半，是由前一半的第1个数取反而来，而第1个数又是由第1行得来（第一行为0）结束，过程中共取反3次，即是由0取反3次得来，所以结果为1</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//记录取反的次数</span></span><br><span class="line">        <span class="keyword">while</span>(N &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, N - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(K &gt; mid)&#123;<span class="comment">//在这一行的后一半，说明是由前一半的第K - mid个数取反而来</span></span><br><span class="line">                cnt++;</span><br><span class="line">                K -= mid;</span><br><span class="line">            &#125;</span><br><span class="line">            N--;  </span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快慢指针之链表中间节点</title>
      <link href="/lihaoran0219.github.io/2020/03/23/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B9%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/"/>
      <url>/lihaoran0219.github.io/2020/03/23/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B9%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><pre><code>输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</code></pre><p>示例 2：</p><pre><code>输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</code></pre><p>提示：</p><p>给定链表的结点数介于 1 和 100 之间。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>定义快慢指针：</p><p>初始都指向链表的头结点</p><p>慢指针每次走一步，快指针每次走两步</p><p>当快指针走到链表最末端或者为空时，慢指针正好走到了链表的中间</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="链表无头结点"><a href="#链表无头结点" class="headerlink" title="链表无头结点"></a>链表无头结点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head; <span class="comment">//快指针</span></span><br><span class="line">        ListNode low = head; <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表有头结点"><a href="#链表有头结点" class="headerlink" title="链表有头结点"></a>链表有头结点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head; <span class="comment">//快指针</span></span><br><span class="line">        ListNode pre = head; <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = (p.next == <span class="keyword">null</span> ? p.next : p.next.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>650.只有两个键的键盘</title>
      <link href="/lihaoran0219.github.io/2020/03/21/650.%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/"/>
      <url>/lihaoran0219.github.io/2020/03/21/650.%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</p><p>Paste (粘贴) : 你可以粘贴你上一次复制的字符。</p><p>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。</p><p>输出能够打印出 n 个 ‘A’ 的最少操作次数。</p><p>示例 1:</p><pre><code>输入: 3输出: 3解释:最初, 我们只有一个字符 &apos;A&apos;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &apos;AA&apos;。第 3 步, 我们使用 Paste 操作来获得 &apos;AAA&apos;。</code></pre><p>说明:</p><p>n 的取值范围是 [1, 1000] 。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>当n为质数时，只能一个一个复制得到n个’A’</p><p>当n不为质数时，我们可以找到n除了自身最大的因数：</p><pre><code>例如：n=1515的最大因数为5，可由5个&apos;A&apos;再复制两次得到可得递归方程为：假设g是n除了自身最大的因数f(n) = f(g) + n / g  n不是质数      （实际是f(g) + 1  + n/g - 1）f(n) = n             n是质数</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//递归出口</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)&#123;  <span class="comment">//找n的最大因数</span></span><br><span class="line">           <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> minSteps(i) + n / i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i / <span class="number">2</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = dp[j] + i / j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水壶问题（裴蜀定理的应用）</title>
      <link href="/lihaoran0219.github.io/2020/03/21/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%88%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/"/>
      <url>/lihaoran0219.github.io/2020/03/21/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%88%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><p>示例 1: (From the famous “Die Hard” example)</p><pre><code>输入: x = 3, y = 5, z = 4输出: True解释：将y装满，再倒给x,此时y还剩2     把x清空，将y中剩的2L倒给x(此时x还能装1L)                将y装满，再给x倒水将x装满，此时y中剩下的恰好是4L</code></pre><p>示例 2:</p><pre><code>输入: x = 2, y = 6, z = 5输出: False</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的意思很简单，就是求一个x升的水壶和一个y升的水壶能否装z升的水，即：</p><pre><code>ax + by = z是否有解</code></pre><p>这里先引用百度对于裴祖公式的解释</p><pre><code>在数论中，裴蜀定理是一个关于最大公约数（或最大公约式）的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，</code></pre><p>说明了<strong>对任何整数a、b和它们的最大公约数d</strong>，关于未知数x和y的线性丢番图方程（称为裴蜀等式）：</p><p><strong>ax + by = m有解当且仅当m是d的倍数。</strong></p><pre><code>裴蜀等式有解时必然有无穷多个整数解 ，每组解x、y都称为裴蜀数，可用辗转相除法求得。例如，12和42的最大公因子是6，则方程12x + 42y = 6有解。事实上有（-3）×12 + 1×42 = 6及4×12 + (-1）×42 = 6。特别来说，方程 ax + by = 1 有解当且仅当整数a和b互素。裴蜀等式也可以用来给最大公约数定义：d其实就是最小的可以写成ax + by形式的正整数。这个定义的本质是整环中“理想”的概念。因此对于多项式整环也有相应的裴蜀定理。</code></pre><p><strong>它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.</strong></p><p>因此，我们只需判断x和y的最大公约数能否被z整除即可（在此基础上，还需要z &lt;= x + y,否则两个水壶装不下）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gcd = gcd(x, y);<span class="comment">//最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(gcd == <span class="number">0</span>)<span class="keyword">return</span> z &lt;= x + y;</span><br><span class="line">        <span class="keyword">return</span> z % gcd == <span class="number">0</span> &amp;&amp; z &lt;= x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//返回a,b的最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>topK问题的两种经典解法</title>
      <link href="/lihaoran0219.github.io/2020/03/20/topK%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95/"/>
      <url>/lihaoran0219.github.io/2020/03/20/topK%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><pre><code>输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]</code></pre><p>示例 2：</p><pre><code>输入：arr = [0,1,2,1], k = 1输出：[0]</code></pre><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这道题是经典的topK问题，本题是求一组数据中最小的K个数据，与之相同的还有求一组数据中最大的k个数据。方法都是相同的，这里介绍了两种解决topK问题的经典算法。</p><h3 id="方法一-堆"><a href="#方法一-堆" class="headerlink" title="方法一 堆"></a>方法一 堆</h3><p>比较直观的想法是使用堆数据结构来辅助得到最小的 k 个数。</p><p>堆的性质是每次可以找出最大或最小的元素。</p><p>我们可以使用一个大小为 k 的最大堆（大顶堆），将数组中的元素依次入堆，当堆的大小超过 k 时，便将多出的</p><p>元素从堆顶弹出。我们以数组 {5, 4, 1, 3, 6, 2, 9},k=3 为例展示元素入堆的过程，如下面动图所示：</p><p><img src="/lihaoran0219.github.io/2020/03/20/topK%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95/heap.gif" alt></p><p>这样，<strong>由于每次从堆顶弹出的数都是堆中最大的，最小的 k 个元素一定会留在堆里。</strong>这样，把数组中的元素全部入堆之后，堆中剩下的 k 个元素就是最大的 k 个数了。</p><p>在这里使用 Java 中的 PriorityQueue实现堆数据结构。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">    <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (i1, i2) -&gt; Integer.compare(i2, i1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">        <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123;</span><br><span class="line">            heap.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">            heap.poll(); <span class="comment">// 删除堆顶最大元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">        res[j++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法的复杂度分析："><a href="#算法的复杂度分析：" class="headerlink" title="算法的复杂度分析："></a>算法的复杂度分析：</h4><ul><li><p>由于使用了一个大小为 k 的堆，空间复杂度为 O(k)；</p></li><li><p>入堆和出堆操作的时间复杂度均为 O(log k)，每个元素都需要进行一次入堆操作，故算法的时间复杂度为 O(nlogk)。</p></li></ul><h3 id="方法二-快速选择算法（快排的变形）"><a href="#方法二-快速选择算法（快排的变形）" class="headerlink" title="方法二 快速选择算法（快排的变形）"></a>方法二 快速选择算法（快排的变形）</h3><p>Top K 问题的另一个解法就比较难想到，需要在平时有算法的积累。</p><p>实际上，“查找第 k 大的元素”是一类算法问题，称为选择问题。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。</p><p>这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p><p>在快速排序中，有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边。</p><p>这个 partition 操作是原地进行的，需要 O(n) 的时间，接下来，快速排序会递归地排序左右两侧的数组。</p><p>而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p><p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 q，也就是说，左侧的数组有q 个元素，是原数组中最小的 q个数。那么：</p><ul><li>若 k = q，我们就找到了最小的 k 个数，就是左侧的数组；</li><li>若 k &lt; q ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li>若 k &gt; q，则左侧数组中的 q 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k- q 个数，对右侧数组递归地 partition 即可。</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        quickSelect(arr, k, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> q = partition(arr, begin, end);</span><br><span class="line">            <span class="keyword">if</span>(q == k)<span class="keyword">return</span>;  <span class="comment">//q左侧的k个数是最小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(q &gt; k)<span class="comment">//说明最小的k个数一定在左侧，继续在左侧划分</span></span><br><span class="line">                quickSelect(arr, k, begin, q - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//说明右侧还有k - q个最小的元素</span></span><br><span class="line">                quickSelect(arr,k, q + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123; <span class="comment">//和快排的partition算法相同</span></span><br><span class="line"><span class="keyword">int</span> i = lo;</span><br><span class="line"><span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v = a[lo];<span class="comment">// 基准元素</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (a[++i] &lt; v) &#123; <span class="comment">// 指针i从前往后找到比基准元素大的值停下</span></span><br><span class="line"><span class="keyword">if</span> (i == hi)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (a[--j] &gt; v) &#123; <span class="comment">// 指针j从后往前找到比基准元素小的值停下</span></span><br><span class="line"><span class="keyword">if</span> (j == lo)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt;= j)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">swap(a, i, j);<span class="comment">// i,j指向的值交换位置</span></span><br><span class="line">&#125;</span><br><span class="line">swap(a, lo, j);<span class="comment">// 一趟走完此时j指向的位置是基准元素应该在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法的复杂度分析：-1"><a href="#算法的复杂度分析：-1" class="headerlink" title="算法的复杂度分析："></a>算法的复杂度分析：</h4><ul><li><p>空间复杂度 O(1)，不需要额外空间。</p></li><li><p>时间复杂度的分析方法和快速排序类似。由于快速选择只需要递归一边的数组，时间复杂度小于快速排序，期望时间复杂度为 O(n)，最坏情况下的时间复杂度为 O(n^2)。</p></li></ul><h3 id="两种方法的优劣性比较"><a href="#两种方法的优劣性比较" class="headerlink" title="两种方法的优劣性比较"></a>两种方法的优劣性比较</h3><p>看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：</p><p>第一，算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</p><p>第二，算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>264.第N个丑数</title>
      <link href="/lihaoran0219.github.io/2020/03/19/264-%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0/"/>
      <url>/lihaoran0219.github.io/2020/03/19/264-%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个程序，找出第 n 个丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例:</p><pre><code>输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</code></pre><p>说明:  </p><ol><li>1是丑数。</li><li>n不超过1690。</li></ol><a id="more"></a><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>首先想到的是暴力法，逐个判断每一个数是否是丑数，意料之中的超时！！</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUgly(result)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用优先队列（小顶堆）</p><p>堆中初始为有元素1，然后每次弹出堆中最小的丑数num并将num * 2,num * 3, num * 5加入到堆中</p><p>这里我使用Java中的TreeSet,加入的数自动排序并去除重复值，避免了加入重复值如2 * 3 = 6 和 3 * 2 = 6</p><p>重复n次后就找到了第n个丑数（耗时105ms,并不理想！！）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        set.add(<span class="number">1l</span>);</span><br><span class="line">        <span class="keyword">while</span>(count &lt; n)&#123;</span><br><span class="line">            res = set.pollFirst(); <span class="comment">//弹出第一个元素（当前集合中最小的丑数）</span></span><br><span class="line">            set.add(res * <span class="number">2</span>);</span><br><span class="line">            set.add(res * <span class="number">3</span>);</span><br><span class="line">            set.add(res * <span class="number">5</span>);</span><br><span class="line">            count++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>动态规划（三指针法）</p><p>我们先模拟手写丑数的过程：</p><p>初始为1，1乘2 1乘3 1乘5，现在是{1,2,3,5}</p><p>轮到2，2乘2 2乘3 2乘5，现在是{1,2,3,4,5,6,10}</p><p>手写的过程和方法二的小顶堆很像，但是怎么做到提前排序呢</p><p>小顶堆的方法是先存再排，dp的方法则是先排再存</p><p>我们设3个指针p2,p3,p5</p><p>代表的是第几个数的2倍、第几个数3倍、第几个数5倍</p><p>动态方程dp[i] = min(dp[p2]<em>2,dp[p3]</em>3,dp[p5]*5)</p><p>小顶堆是一个元素出来然后存3个元素</p><p>动态规划则是标识3个元素，通过比较他们的2倍、3倍、5倍的大小，来一个一个存</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = Math.min(Math.min(dp[p2] * <span class="number">2</span>, dp[p3] * <span class="number">3</span>), dp[p5] * <span class="number">5</span>);<span class="comment">//选三个数中的最小值</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p2] * <span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p3] * <span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p5] * <span class="number">5</span>) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>409. 最长回文串</title>
      <link href="/lihaoran0219.github.io/2020/03/19/409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/lihaoran0219.github.io/2020/03/19/409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p><p>注意:<br>假设字符串的长度不会超过 1010。</p><p>示例 1:</p><pre><code>输入:&quot;abccccdd&quot;输出:7解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于一个回文串，如果长度为偶数时，那么所有的字符都出现偶数次，如abccba</p><p>如果长度为奇数时，只有一个字符出现奇数次，如ababa</p><p>基于此，我们只需统计给定字符串中每个字符出现的次数，然后每个字符尽可能多的拿偶数个，</p><p>最后如果还有剩余的字符，再拿一个，这样的策略保证构造的回文串最长</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];<span class="comment">// 记录s中每个字符出现的次数 A(65) -- z(122)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray())</span><br><span class="line">rec[ch - <span class="string">'A'</span>]++;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 记录最长回文串的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rec.length; i++) &#123;</span><br><span class="line">res += rec[i] / <span class="number">2</span> * <span class="number">2</span>; <span class="comment">// 每一个字符拿偶数个</span></span><br><span class="line"><span class="keyword">if</span>(rec[i]  % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; res % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">//回文串中最多有1个字符出现奇数次，所以有奇数个的时候拿一个</span></span><br><span class="line">                res++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客增加评论留言功能</title>
      <link href="/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/"/>
      <url>/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近用hexo搭建了一个博客，这是一个用来生成静态博客的开源框架，要想开启评论功能，我们在这里借助后端云平台LeanCloud</p><p>nexT主题集成了很多评论插件，这里采用Valine</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-前往LeanCloud官网注册账号"><a href="#1-前往LeanCloud官网注册账号" class="headerlink" title="1.前往LeanCloud官网注册账号"></a>1.前往<a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud官网</a>注册账号</h4><h4 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2.创建应用"></a>2.创建应用</h4><p><img src="/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/new.jpg" alt></p><h4 id="3-进入应用→设置→应用key-获取你的appid和appkey"><a href="#3-进入应用→设置→应用key-获取你的appid和appkey" class="headerlink" title="3.进入应用→设置→应用key 获取你的appid和appkey"></a>3.进入应用→设置→应用key 获取你的appid和appkey</h4><p><img src="/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/keys.jpg" alt></p><h4 id="4-打开主题配置文件（blog-themes-next-config-yml）"><a href="#4-打开主题配置文件（blog-themes-next-config-yml）" class="headerlink" title="4.打开主题配置文件（blog/themes/next/_config.yml）"></a>4.打开主题配置文件（blog/themes/next/_config.yml）</h4><pre><code>* 搜索valine* 将enable设置为true* 将获取的id填入相应的位置</code></pre><p><img src="/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/valine.jpg" alt></p><h4 id="大功告成啦！！！"><a href="#大功告成啦！！！" class="headerlink" title="大功告成啦！！！"></a>大功告成啦！！！</h4>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>703. 数据流中的第K大元素</title>
      <link href="/lihaoran0219.github.io/2020/03/18/703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/lihaoran0219.github.io/2020/03/18/703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p><p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 </p><p>KthLargest.add，返回当前数据流中第K大的元素。</p><p>示例:</p><pre><code>int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3);   // returns 4kthLargest.add(5);   // returns 5kthLargest.add(10);  // returns 5kthLargest.add(9);   // returns 8kthLargest.add(4);   // returns 8</code></pre><p>说明:<br>你可以假设 nums 的长度≥ k-1 且k ≥ 1。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过维护一个小顶堆实现</p><p>Java中有PriorityQueue类实现了优先级队列，默认小顶堆，可通过传入外部比较器实现大顶堆</p><p>小顶堆可实现队中只有K个最大的元素</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq;  <span class="comment">//优先级队列（小顶堆）</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pq.size() &lt; k) &#123; <span class="comment">//队中不满K个元素时继续入队</span></span><br><span class="line">            pq.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pq.peek() &lt; val) &#123;<span class="comment">//只有比队首元素大才入队，保证队中只有K个元素</span></span><br><span class="line">            pq.poll();<span class="comment">//弹出队首元素</span></span><br><span class="line">            pq.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>863.矩形重叠</title>
      <link href="/lihaoran0219.github.io/2020/03/18/863-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
      <url>/lihaoran0219.github.io/2020/03/18/863-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p>示例 1：</p><pre><code>输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]输出：true</code></pre><p>示例 2：</p><pre><code>输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]输出：false</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用反证思想，判断两个矩形是否不重叠显然要简单一些</p><p>固定一个矩形，另一个矩形有四种情况：</p><pre><code>矩形 rec2 在矩形 rec1 的左侧；（rec2右下角横坐标小于等于rec1左下角横坐标）矩形 rec2 在矩形 rec1 的右侧；（rec2左下角横坐标大于等于rec1右下角横坐标）矩形 rec2 在矩形 rec1 的上方；（rec2左下角纵坐标大于等于rec1左下角纵坐标）矩形 rec2 在矩形 rec1 的下方  （rec2左上角纵坐标小于等于rec1左下角纵坐标）</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(rec2[<span class="number">1</span>] &gt;= rec1[<span class="number">3</span>]||  <span class="comment">//rec2在rec1上方</span></span><br><span class="line"> rec2[<span class="number">3</span>] &lt;= rec1[<span class="number">1</span>] ||  <span class="comment">//rec2在rec1下方</span></span><br><span class="line"> rec2[<span class="number">2</span>] &lt;= rec1[<span class="number">0</span>]|| <span class="comment">//rec2在rec1左方</span></span><br><span class="line"> rec2[<span class="number">0</span>] &gt;= rec1[<span class="number">2</span>]);  <span class="comment">//rec2在rec1右方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划和贪心+二分查找解决最长上升子序列问题</title>
      <link href="/lihaoran0219.github.io/2020/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%A7%A3%E5%86%B3%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/lihaoran0219.github.io/2020/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%A7%A3%E5%86%B3%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h2 id="解法一：动态规划（O-n-2-）"><a href="#解法一：动态规划（O-n-2-）" class="headerlink" title="解法一：动态规划（O(n^2)）"></a>解法一：动态规划（O(n^2)）</h2><a id="more"></a><p>dp[i]表示以array[i]结尾的最长上升子序列的长度<br>dp[i] = max(dp[0] – dp[j]) + 1 (其中j &lt; i 且 array[j] &lt; array[i])</p><p>例： 1,7,3,5,9,4,8</p><p>（1）dp[i]的元素初值都为1</p><p>（2）dp[0]表示以1结尾的最长上升子序列的长度，为1 </p><p>（3）dp[1]表示以7结尾的最长上升子序列的长度:</p><ul><li>看dp[0],因为array[0] &lt; array[1],所以dp[1] = dp[0] + 1 = 2</li></ul><p>（4）dp[2]表示以7结尾的最长上升子序列的长度:</p><pre><code>看dp[0],dp[1],只有array[0] &lt; array[2]所以dp[2] = dp[0] + 1 = 2</code></pre><p>（5）dp[3]表示以5结尾的最长上升子序列的长度:</p><pre><code>看dp[0],dp[1],dp[2],array[0] &lt; array[3],array[2] &lt; array[3]dp[0]和dp[2]中取最大值dp[2] = 2所以dp[3] = dp[2] + 1 = 3</code></pre><p>（6）dp[4]表示以9结尾的最长上升子序列的长度:</p><pre><code>看dp[0],dp[1],dp[2],dp[3]array[0],array[1],array[2],array[3]都小于&lt;array[4]dp[0],dp[1],dp[2],dp[3]中取最大值dp[3] = 3所以dp[3] = dp[3] + 1 = 4</code></pre><p>（7）dp[5]表示以4结尾的最长上升子序列的长度:</p><pre><code>看dp[0],dp[1],dp[2],dp[3]，dp[4]array[0],array[2]小于&lt;array[5]dp[0],dp[2]中取最大值dp[2] = 2所以dp[3] = dp[2] + 1 = 3</code></pre><p>（8）dp[6]表示以8结尾的最长上升子序列的长度:</p><pre><code>看dp[0],dp[1],dp[2],dp[3],dp[4],dp[5]array[0],array[1],array[2],array[3],array[5]都小于&lt;array[6]dp[0],dp[1],dp[2],dp[3],dp[5]中取最大值 3所以dp[3] = 3 + 1 = 4</code></pre><p>(9)遍历完数组array,求dp数组中的最大值即为最长上升子序列的长度</p><h2 id="解法二：贪心-二分查找（O-nlogn-）"><a href="#解法二：贪心-二分查找（O-nlogn-）" class="headerlink" title="解法二：贪心+ 二分查找（O(nlogn)）"></a>解法二：贪心+ 二分查找（O(nlogn)）</h2><p>对于以某一个数结尾的最长上升子序列，当然是结尾的数越小越好    </p><p>创建一个list,初始有一个元素array[0]</p><p>从下标为1处开始扫描数组array</p><p>如果比list中的最后一个数大，说明可构成上升子序列，直接加入到list中</p><p>如果比list中的最后一个数小，则找到list中第一个大于或等于这个数的元素替换</p><p>查找用二分查找实现</p><p>最终list的长度即为最长上升子序列的长度</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">        <span class="comment">//动态规划法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">            Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(array[j] &lt; array[i]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[j] &gt; max) </span><br><span class="line">                            max = dp[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = max + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxInArray(dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxInArray</span><span class="params">(<span class="keyword">int</span>[] dp)</span> </span>&#123;<span class="comment">//返回dp数组中的最大值</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i] &gt; max)</span><br><span class="line">max = dp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//贪心 + 二分查找 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//res中的元素保持升序</span></span><br><span class="line">        res.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; res.get(res.size() - <span class="number">1</span>))</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.set(binarySearch(res, nums[i]), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; res, <span class="keyword">int</span> key)</span></span>&#123;<span class="comment">//找到list中第一个大于key的值，返回下标</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = res.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(res.get(mid) &lt; key)  <span class="comment">//注意：if else 的位置不能换</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
