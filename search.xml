<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java File类</title>
    <url>/lihaoran0219.github.io/2020/04/17/Java%20%20File%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 构造方法</span><br><span class="line">* &#96;&#96;&#96;File(File parent, String child)</span><br></pre></td></tr></table></figure>
<p>从父抽象路径名和子路径名字符串创建新的 File实例。</p>
<ul>
<li><p><code>File(String pathname)</code><br>通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</p>
<pre><code>参数pathname为路径名称（字符串形式）
路径可以以文件结尾，也可以以文件夹结尾
路径可以存在，也可以不存在</code></pre></li>
<li><p><code>File(String parent, String child)</code><br>从父路径名字符串和子路径名字符串创建新的 File实例。</p>
<pre><code>把路径分为了两部分
parent：父路径
child: 子路径
好处：父路径和子路径可以单独书写，使用起来很灵活</code></pre></li>
<li><p><code>File(URI uri)</code><br>通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。</p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3></li>
<li><p><code>static String pathSeparator</code><br>与系统相关的路径分隔符字符，为方便起见，表示为字符串。</p>
<pre><code>路径分隔符：
    windows系统：;(分号)
    linux系统： :(冒号)</code></pre></li>
<li><p><code>static char pathSeparatorChar</code><br>与系统相关的路径分隔符。</p>
</li>
<li><p><code>static String separator</code><br>与系统相关的默认名称分隔符字符，以方便的方式表示为字符串。</p>
<pre><code>名称分隔字符：
    windows: \ (反斜杠)
    linux： /（正斜杠）</code></pre></li>
<li><p><code>static char separatorChar</code><br>与系统相关的默认名称分隔符。</p>
</li>
</ul>
<p>注意： 为了区分系统，尽量不要把路径写死，用这些静态变量表示</p>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><p>绝对路径： 是一个完整的路径（以盘符开始）</p>
</li>
<li><p>相对路径：是一个简化的路径（以当前项目的根目录开始）</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1.获取"></a>1.获取</h4></li>
<li><p><code>String getAbsolutePath()</code>: 返回此File对象的绝对路径</p>
</li>
<li><p><code>String  getPath()</code>: 返回此File对象的相对路径</p>
</li>
<li><p><code>String  getName()</code>: 返回此File对象表示的文件名称或目录名称</p>
</li>
<li><p><code>long  length()</code>：返回此File对象表示的文件的长度（字节为单位，文件夹没有大小的概念，如果路径不存在，返回0）</p>
<h4 id="2-判断"><a href="#2-判断" class="headerlink" title="2.判断"></a>2.判断</h4></li>
<li><p><code>boolean exists()</code>: 此File对象表示的文件或目录是否存在</p>
</li>
<li><p><code>boolean isDirectory()</code>: 此File对象表示的是否是目录</p>
</li>
<li><p><code>boolean isFile()</code>: 此File对象表示的是否为文件</p>
<h4 id="3-创建和删除"><a href="#3-创建和删除" class="headerlink" title="3.创建和删除"></a>3.创建和删除</h4></li>
<li><p><code>boolean createNewFile()</code>: 当且仅当具有该名称的文件不存在时，创建一个新的空文件</p>
<pre><code>1.此方法只能创建文件，不能创建文件夹
2.创建文件的路径必须存在，否则会抛异常
3.此方声明抛出了IOException，使用时必须处理异常</code></pre></li>
<li><p><code>boolean delete()</code>: 删除由此File对象表示的目录或文件</p>
</li>
<li><p><code>boolean mkdir()</code>: 创建由此File对象表示的目录（单级文件夹）</p>
</li>
<li><p><code>boolean mkdirs()</code>: 创建由此File对象表示的目录，包括任何必须但不存在的父目录（单极或多级文件夹）</p>
<h4 id="4-目录的遍历"><a href="#4-目录的遍历" class="headerlink" title="4.目录的遍历"></a>4.目录的遍历</h4></li>
<li><p><code>String[] list()</code>: 返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录。</p>
</li>
<li><p><code>File[] listFiles()</code>: 返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。</p>
<pre><code>1.路径不存在，会抛出空指针异常
2.如果路径不是一个目录，也会抛出空指针异常
3.隐藏文件或隐藏文件夹也可以遍历到</code></pre><p>示例：递归打印多级目录</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 递归打印多级目录 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\Drivers"</span>);</span><br><span class="line">        getAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFiles</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())  <span class="comment">//如果是一个目录就继续遍历</span></span><br><span class="line">                getAllFiles(file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/lihaoran0219.github.io/2020/04/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Lambda 表达式（lambda expression）是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数</p>
<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。<br>&lt;–! more –&gt;</p>
<h3 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h3><p>我们在上一篇文章中讲到多线程时，常常用到Runnable接口定义线程的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03InnerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在匿名内部类中，其实只有方法体才是关键所在，那我们可以不创建这个匿名内部类吗？</p>
<h3 id="Lambda初体验"><a href="#Lambda初体验" class="headerlink" title="Lambda初体验"></a>Lambda初体验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span>简化<span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就将代码简化了</p>
<ul>
<li><p>()表示run()方法的参数，此处没有参数‘</p>
</li>
<li><p>-&gt;表示将前面的参数传递给后面的代码</p>
</li>
<li><p>后面的输出语句即为业务逻辑代码</p>
<h3 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h3><p>Lambda表达式省去了面向对象的一些条条框框，格式由3部分组成：</p>
</li>
<li><p>一些参数</p>
</li>
<li><p>一个箭头</p>
</li>
<li><p>一段代码</p>
<figure class="highlight plain"><figcaption><span>参数名称) ->  &#123;代码&#125;```</span></figcaption><table><tr><td class="code"><pre><span class="line">没有参数括号中就没有内容，多个参数用逗号隔开</span><br><span class="line"></span><br><span class="line">再来举个例子，在排序的时候我们经常用Arrays.sort()方法传入一个比较器自定义比较规则，我么们也可以用Lambda表达式简写</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class demo02简化Comparator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arr &#x3D; &#123;98, -4, 2, 7, 11, 4, 8&#125;;</span><br><span class="line">        &#x2F;&#x2F;降序排序</span><br><span class="line">        Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                return o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;Lambda表达式</span><br><span class="line">        &#x2F;&#x2F;Arrays.sort(arr, (Integer o1, Integer o2) -&gt; o2 - o1);</span><br><span class="line">        Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);&#x2F;&#x2F;参数类型可以不写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以省略的内容：</p>
</li>
<li><p>参数列表的数据类型可以省略不写</p>
</li>
<li><p>如果参数只有一个，括号也可以不写</p>
</li>
<li><p>代码只有一行，{}， return 和分号 可以不写（要不写则都不写）</p>
<h3 id="Lambda使用前提"><a href="#Lambda使用前提" class="headerlink" title="Lambda使用前提"></a>Lambda使用前提</h3></li>
<li><p>必须具有接口，且接口中<strong>仅有一个抽象方法</strong></p>
</li>
<li><p>必须具有<strong>上下文推断</strong>（参数类型需和接口对应）</p>
<pre><code>备注：只有一个抽象方法的接口成为函数式接口</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/lihaoran0219.github.io/2020/04/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1.并发与并行"></a>1.并发与并行</h3><ul>
<li>并发：指两个或多个事件在<strong>同一时间段内</strong>发生</li>
<li>并行：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）<br><img src="https://img-blog.csdnimg.cn/2020041612452826.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><a id="more"></a>
<h3 id="2-线程与进程"><a href="#2-线程与进程" class="headerlink" title="2.线程与进程"></a>2.线程与进程</h3></li>
<li>进程：指一个内存中运行的应用程序，每个进程都有一个独立的运行空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li>
<li>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，有多个线程的程序成为多线程程序。<br><img src="https://img-blog.csdnimg.cn/20200416125412168.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>线程调度：</li>
<li>分时调度<br> 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间<ul>
<li>抢占式调度<br>优先让优先级高的线程使用CPU，如果线程的优先级相同，会随机选择一个线程（线程随机性），Java使用抢占式调度<h3 id="3-创建线程类"><a href="#3-创建线程类" class="headerlink" title="3.创建线程类"></a>3.创建线程类</h3>Java使用<code>Java.lang.Thread</code>类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序。<h4 id="创建多线程方法一"><a href="#创建多线程方法一" class="headerlink" title="创建多线程方法一"></a>创建多线程方法一</h4></li>
</ul>
</li>
<li>定义Thread类的子类，并重写该类的run()方法，该run方法中的内容就是线程需要完成的任务，因此把run()方法称为线程执行体</li>
<li>创建Thread子类的实例，即创建线程对象</li>
<li>调用线程对象的start()方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建多线程的第一种方式：创建Tread类的子类</span></span><br><span class="line"><span class="comment">1.定义一个类，继承Thread类</span></span><br><span class="line"><span class="comment">2.重写Thread类中的run()方法</span></span><br><span class="line"><span class="comment">3.创建子类的实例</span></span><br><span class="line"><span class="comment">4.调用对象的start()方法启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"run: "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main: "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h4><p>我们从以上程序的输出可以发现，程序是一会儿执行主线程，一会执行我们创建的线程，是随机的<br>两个线程一起抢夺CPU的执行时间，谁抢到了就执行</p>
<h4 id="多线程的内存"><a href="#多线程的内存" class="headerlink" title="多线程的内存"></a>多线程的内存</h4><p>每开启一个 线程，都会开辟一个独立的栈空间<br>每个线程之间独立，互不影响<br><img src="https://img-blog.csdnimg.cn/20200416135008431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="创建多线程方法二"><a href="#创建多线程方法二" class="headerlink" title="创建多线程方法二"></a>创建多线程方法二</h4><ul>
<li>创建一个类，实现Runnable接口</li>
<li>实现run()方法</li>
<li>创建Runnable接口的实现类对象<br>注：因为类没有继承Thread，所以该类的实例没有start()方法<br>Thread类 的构造方法允许传入一个Runnable接口的实现对象<br>要想开启线程需要用带Runnable参数的构造方法创建一个Thread对象，调用该对象的start()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建多线程的第二种方式：实现Runnable接口</span></span><br><span class="line"><span class="comment">1.定义一个类，继承Thread类</span></span><br><span class="line"><span class="comment">2.重写Thread类中的run()方法</span></span><br><span class="line"><span class="comment">3.创建子类的实例</span></span><br><span class="line"><span class="comment">4.调用对象的start()方法启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现多线程的两种方法区别"><a href="#实现多线程的两种方法区别" class="headerlink" title="实现多线程的两种方法区别"></a>实现多线程的两种方法区别</h4><p>如果一个类继承Threa，则不适合资源共享。但是如果实现了Runnable接口，则容易实现资源共享。<br>总结：<br><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p>
<pre><code>1.适合多个相同的程序代码去共享一个资源
2.可以避免Java中单继承的局限性（继承了Thread类就不能继承别的类了）
3.增加程序的健壮性，实现解耦操作，代码可以被多个先线程共享，代码和线程独立
4.线程池只能放入Runnable或Callable类线程，不能直接放入继承Thread的类</code></pre><p>扩充：<br>    在Java中，每次执行程序 至少或启动两个线程，一个是main线程，一个是垃圾收集线程</p>
<h4 id="匿名内部类创建多线程"><a href="#匿名内部类创建多线程" class="headerlink" title="匿名内部类创建多线程"></a>匿名内部类创建多线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03InnerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4.线程安全"></a>4.线程安全</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>比如说电影院售票问题，一个售票窗口的时候不会出什么问题，但是多个窗口时就有可能同时出售同一张票，这显然是不应该的<br><img src="https://img-blog.csdnimg.cn/2020041615074529.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们来模拟一下三个窗口同时售票的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo04ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl r = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">/*3个线程模拟3个窗口*/</span></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200416174040314.png#pic_center" alt="在这里插入图片描述"><br>我们发现出现了重复卖票的情况，那么出现这种情况的原因是什么呢？<br>上文中说过，Java采用抢占式调度，谁抢到了CPU的执行时间谁就就执行<br>在线程0卖完第100张票还没来得及更新票的时候，线程1抢到了执行时间，线程1失去了执行权，线程1也来卖票，此时他认为100还没卖出去，继续卖，这就产生了上述情况。<br>这在现实生活中是不能够发生的。<br>那么我们如何避免产生这一类的问题呢？<br>其实我们只需要保证在一个线程在访问公共资源时，无论其是否失去了CPU的执行权，都让其他的线程无法访问公共资源<br>接下来就来讲讲如何实现</p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制<br>有3中方式完成同步操作：</p>
<pre><code>1.同步代码块
2.同步方法
3.锁机制</code></pre><p><strong>1.同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决线程安全问题方法一：使用同步代码块</span></span><br><span class="line"><span class="comment">模式：</span></span><br><span class="line"><span class="comment">synchronized(锁对象)&#123;</span></span><br><span class="line"><span class="comment">    可能出现线程安全问题的代码块</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">    1.通过代码块中的锁对象，可以使用任意的对象</span></span><br><span class="line"><span class="comment">    2.但是必须保证多个线程使用的锁对象是同一个</span></span><br><span class="line"><span class="comment">    3.锁对象的作用：</span></span><br><span class="line"><span class="comment">        把同步代码块锁住，只让一个线程在同步代码块中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo05ThreadSafe2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">//创建一个锁对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (obj)&#123;  <span class="comment">//同步代码块</span></span><br><span class="line">                   <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                       System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                       ticket--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl r = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>同步的原理：</strong><br>使用了一个锁对象<br>3个线程同时抢夺CPU执行权，谁抢到了谁执行run()方法进行卖票<br>t0抢到了，执行run()方法，遇到synchronized代码块，会检查是否有锁对象<br>发现有，就获取到锁对象，进入到同步代码块中<br>t1抢到了执行权，执行run()方法，遇到synchronized代码块，检查是否有锁对象<br>发现没有锁对象，就会进入阻塞状态，会一直等到t0线程归还锁对象，等t0执行完归还锁对象后t1才能进入同步代码块<br><strong>2.同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决线程安全问题方法一：使用同步方法</span></span><br><span class="line"><span class="comment">1.将访问了共享数据的代码抽取出来放到一个方法中</span></span><br><span class="line"><span class="comment">2.在方法上添加synchronized修饰符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo06ThreadSafe3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">//创建一个锁对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                pay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   			定义一个同步方法</span></span><br><span class="line"><span class="comment">   			同步方法的锁对象其实就是执行方法的实现类对象（this）</span></span><br><span class="line"><span class="comment">   			注意：如果同步方法是静态的，那么锁对象是本类的class属性（class文件对象）</span></span><br><span class="line"><span class="comment">   		 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl r = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.Lock锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Lock锁将获取锁和释放锁方法化</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;public void lock()&#96;&#96;&#96;: 加同步锁</span><br><span class="line">&#96;&#96;&#96;public void unlock()&#96;&#96;&#96;:释放同步锁</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">解决线程安全问题方法三：使用Lock锁</span><br><span class="line">java.util.concurrent.locks.reentrantLock 实现了lock接口</span><br><span class="line"></span><br><span class="line">1.创建reentrantLock类的对象</span><br><span class="line">2.在可能会出现线程安全的位置前调用Lock接口的lock()方法</span><br><span class="line">3.在可能会出现线程安全的位置后面调用Lock接口的unlock()方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class demo07ThreadSafe4 &#123;</span><br><span class="line">    static class RunnableImpl implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private int ticket &#x3D; 100;</span><br><span class="line">        Lock lock &#x3D; new ReentrantLock(); &#x2F;&#x2F;1.创建reentrantLock类的对象</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                lock.lock();&#x2F;&#x2F;2.在可能会出现线程安全的位置前调用Lock接口的lock()方法</span><br><span class="line">                try&#123;</span><br><span class="line">                    if (ticket &gt; 0) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;正在卖第&quot; + ticket + &quot;张票&quot;);</span><br><span class="line">                        ticket--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();&#x2F;&#x2F;3.在可能会出现线程安全的位置后面调用Lock接口的unlock()方法</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RunnableImpl r &#x3D; new RunnableImpl();</span><br><span class="line">        Thread t0 &#x3D; new Thread(r);</span><br><span class="line">        Thread t1 &#x3D; new Thread(r);</span><br><span class="line">        Thread t2 &#x3D; new Thread(r);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-线程的状态"><a href="#5-线程的状态" class="headerlink" title="5.线程的状态"></a>5.线程的状态</h3><p><img src="https://img-blog.csdnimg.cn/20200416194353821.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p><strong>1.线程间通信</strong></p>
<p><strong>概念</strong>：多个线程在处理同一个资源，但处理的动作不同</p>
<p>比如线程1生产包子，线程2吃包子，包子就是资源，两个线程都是处理包子，但任务不同，两个线程就存在线程通信问题</p>
<p><strong>为什么要处理线程间的通信问题</strong></p>
<p>多个线程并发执行时，在默认情况下CPU是随机切换线程的，当我们需要多个线程共同来完成一件任务，并且我们需要他们按照规律执行时，就需要进行协调通信。</p>
<p><strong>如何实现线程间通信</strong><br>等待唤醒机制</p>
<p><strong>2.等待唤醒机制</strong></p>
<p><strong>什么是等待唤醒机制</strong><br>即多线程间的<strong>协作</strong>机制</p>
<p>还是以包子为例：<br><img src="https://img-blog.csdnimg.cn/20200416204851349.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY5MjIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>等待唤醒中的方法：</p>
<p>1.wait() : 线程不再活动，不再参与调度，进入wait set，这时线程的状态为        WAITING。他还要等着别的线程执行<strong>notify</strong>，在这个对象上等待的线程从wait set中释放出来，进入调度队列<br>2.notify() : 选取所通知对象wait set 中的一个线程释放<br>3.notifyAll() : 释放所通知对象wait set 中的所有线程</p>
<p>我们还是以包子铺为例实现一下生产包子和吃包子两个线程间的通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo09</span>等待唤醒案例2 </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    包子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Baozi</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String p; <span class="comment">//包子皮</span></span><br><span class="line">        String x;<span class="comment">//包子馅</span></span><br><span class="line">        Boolean status = <span class="keyword">false</span>;<span class="comment">//包子的状态</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    包子铺类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Baozi b; <span class="comment">//包子当作锁对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Shop</span><span class="params">(Baozi b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b.status)&#123;  <span class="comment">//此时有包子</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            b.wait(); <span class="comment">//包子铺进入等待状态</span></span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*被唤醒之后*/</span></span><br><span class="line">                    <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//生产薄皮三鲜馅的包子</span></span><br><span class="line">                        b.p = <span class="string">"薄皮"</span>;</span><br><span class="line">                        b.x = <span class="string">"三鲜"</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//生产冰皮牛肉大葱馅包子</span></span><br><span class="line">                        b.p = <span class="string">"冰皮"</span>;</span><br><span class="line">                        b.x = <span class="string">"牛肉大葱"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(<span class="string">"包子铺正在生产"</span> + b.p + b.x + <span class="string">"包子"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);<span class="comment">//生产包子需要3秒</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    b.status = <span class="keyword">true</span>;  <span class="comment">//修改包子的状态</span></span><br><span class="line">                    b.notify(); <span class="comment">//唤醒吃货线程</span></span><br><span class="line">                    System.out.println(b.p + b.x + <span class="string">"包子生产好了！！！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    吃货类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Eat</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Baozi b; <span class="comment">//包子当作锁对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Eat</span><span class="params">(Baozi b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!b.status)&#123; <span class="comment">//没有包子</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            b.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*被唤醒之后*/</span></span><br><span class="line">                    System.out.println(<span class="string">"吃货正在吃"</span> +b.p + b.x + <span class="string">"包子"</span>);</span><br><span class="line">                    b.status = <span class="keyword">false</span>; <span class="comment">//包子吃完了，修改包子的状态</span></span><br><span class="line">                    b.notify(); <span class="comment">//唤醒包子铺线程</span></span><br><span class="line">                    System.out.println(<span class="string">"吃货已经把"</span> +b.p + b.x + <span class="string">"包子吃完了，包子铺开始生产"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Baozi b = <span class="keyword">new</span> Baozi(); <span class="comment">//创建包子对象</span></span><br><span class="line">        <span class="keyword">new</span> Shop(b).start();<span class="comment">//开启包子铺线程</span></span><br><span class="line">        <span class="keyword">new</span> Eat(b).start();<span class="comment">//开启吃货线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h3><p>当并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率<br>那么有没有一种方法可以使线程复用，不必再每次创建线程呢？Java中可以使用线程池达到这样的效果。</p>
<p>线程池实际上就是一个存放线程的集合（ArrayList, LinkedList等）<br>在JDK1.5以后内置了线程池</p>
<p>Java里面线程池的顶级接口时<code>java.util.concurrent.Executors</code>，该类是线程池的工厂类<br>Executor类中创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThread)</code><br>返回线程池对象，可以指定池中线程的数量</li>
<li><code>public  future&lt;?&gt; submit(Runnable task)</code><br>  获取线程池中某一线程对象，并执行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo10ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用线程池工厂类Executors的静态方法newFixedThreadPool生成一个指定线程数量的线程池</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//2.创建一个类，实现Runna接口，重写run()方法</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"已开始"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.调用 ExecutorService中的submit()方法，传递线程任务，开启线程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> RunnableImpl());  <span class="comment">//线程池会一直开启，使用完的线程会自动归还给线程池，可重复使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/lihaoran0219.github.io/2020/04/15/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + Enter</td>
<td>导入包，自动修正代码</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制光标所在行</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>单行注释，再按取消注释</td>
</tr>
<tr>
<td>Ctrl + Shift +  /</td>
<td>选中代码注释，再按取消注释</td>
</tr>
<tr>
<td>Alt + Ins</td>
<td>自动生成代码，toString,get,set等方法，新建文件等</td>
</tr>
<tr>
<td>Alt + Shift + 上下箭头</td>
<td>移动当前代码行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>有多少小于当前数字的数字</title>
    <url>/lihaoran0219.github.io/2020/04/14/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。</p>
<p>以数组形式返回答案。</p>
<p>示例 1：</p>
<pre><code>输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</code></pre><p>示例 2：</p>
<pre><code>输入：nums = [6,5,4,8]
输出：[2,1,0,3]</code></pre><p>示例 3：</p>
<pre><code>输入：nums = [7,7,7,7]
输出：[0,0,0,0]</code></pre><p>提示：</p>
<pre><code>2 &lt;= nums.length &lt;= 500
0 &lt;= nums[i] &lt;= 100</code></pre> <a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一 暴力法"></a>方法一 暴力法</h4><p>定一个数，然后从后面找比它小的数，找到则计数器加一（时间复杂度O(N^2)）</p>
<h4 id="方法二-排序"><a href="#方法二-排序" class="headerlink" title="方法二  排序"></a>方法二  排序</h4><p>将数组排好序，然后等于nums[i]的第一个元素的下标即为比它小的元素个数</p>
<p>这里我用了线性查找和二分查找两种方法查找第一个等于nums[i]的元素</p>
<h3 id="方法三-计数-前缀和数组"><a href="#方法三-计数-前缀和数组" class="headerlink" title="方法三 计数 + 前缀和数组"></a>方法三 计数 + 前缀和数组</h3><pre><code>这种方法类似于计数排序
因为元素的范围为0--100，所以我们定义一个长度为101的数组bucket
遍历一遍数组，元素转下标，记录出现的次数
然后我们将bucket数组转化为前缀和数组（即bucket[i] = bucket[i] + bucket[i - 1]）
这样一来bucket[i]表示小于等于i的元素个数
所以bucket[i - 1]表示小于i的元素个数</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = nums.clone();</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = indexOf(temp, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//线性查找最左边的target下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = nums.clone();</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = indexOf(temp, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="comment">//桶用来记录每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) </span><br><span class="line">            bucket[num]++;</span><br><span class="line">        <span class="comment">//将桶数组变成前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">            bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时bucket[i]表示小于等于i的数的个数</span></span><br><span class="line">        <span class="comment">//所以bucket[i - 1]表示小于i的数的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = nums[i] == <span class="number">0</span> ? <span class="number">0</span> : bucket[nums[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表加法</title>
    <url>/lihaoran0219.github.io/2020/04/14/%E9%93%BE%E8%A1%A8%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p>示例：</p>
<pre><code>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre>  <a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>问题的关键在于链表的顺序和加法的顺序相反，我们要实现加法就要从链表的尾部开始</p>
<p>先遍历到链表尾部再相加的办法的办法真是太过于朴素了</p>
<p>其实对于逆序这一类问题我们应该首先想到的就是栈，利用栈很容易就将链表中的元素倒过来了</p>
<pre><code>1.遍历两个链表，将元素入栈
2.依次从两个栈中弹出栈顶元素相加
3.每一位上的数字应该是加完的结果对10取余加上进位
4.用头插法创建链表存储结果
5.保存进位</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode p = l1;</span><br><span class="line">        ListNode q = l2;</span><br><span class="line">        <span class="comment">/*将链表元素用栈保存*/</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.push(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.push(q.val);</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*分别弹出两个栈的栈顶元素相加*/</span></span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty() ||  carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += s1.isEmpty() ? <span class="number">0</span> : s1.pop();</span><br><span class="line">            sum += s2.isEmpty() ? <span class="number">0</span> : s2.pop();</span><br><span class="line">            <span class="comment">/*头插法添加链表结点*/</span></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = res;</span><br><span class="line">            res = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;  <span class="comment">//存储进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>航班预定统计</title>
    <url>/lihaoran0219.github.io/2020/04/09/%E8%88%AA%E7%8F%AD%E9%A2%84%E5%AE%9A%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p>
<p>我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。</p>
<p>请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。</p>
<p>示例：</p>
<pre><code>输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]</code></pre><p>提示：</p>
<pre><code>1 &lt;= bookings.length &lt;= 20000
1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000
1 &lt;= bookings[i][2] &lt;= 10000</code></pre> <a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1.暴力法"></a>1.暴力法</h4><p>外层循环遍历bookings数组</p>
<p>内层循环从i到j，转下标用数组rec记录每个航班的预定数</p>
<p>如[2, 5, 25]:</p>
<pre><code>则rec[2] += 25, 
rec[3] += 25, 
rec[4] += 25, 
rec[5] += 25</code></pre><p>####2.差分法</p>
<p>解法1每次都要从i到j遍历一次，我们可以进行一下优化</p>
<p>其实从i到j,每一个都加上k，这不就是等差数组嘛</p>
<p>我们只需遍历一遍bookings,用一个数组记录公差d,最后等差公式an = a(n - 1) + d即可</p>
<p>举个栗子：</p>
<p>假设d[0] = 0,我们从d[1]开始</p>
<p>[1, 2, 10]</p>
<pre><code>航班1预定了10，则和d[0]的公差为10，d[1] = 10
航班2预定了10，则比航班3多10，即2和3的公差为-10，d[3] = -10</code></pre><p>[2, 3, 20]</p>
<pre><code>航班2和航班3预定了20
航班2比航班1多了20，则1和2的公差为20， d[2] = 20
航班3比航班4多了20，即3和4的公差为-20，d[4] = -20</code></pre><p>[2, 5, 25]</p>
<pre><code>航班2， 3， 4， 5都预定了25
航班2又比航班1多了25，则公差变成了原来的20再加上25，即d[2] += 25 = 45
推算到此结束，因为2，3，4，5都加了25，他们之间不会再拉开差距</code></pre><p>至此，数组d = [0, 10, 45, -10, -20, 0]</p>
<p>根据等差数列通项公式ans = [10, 55, 45, 25, 25]</p>
<p>总结一下就是：</p>
<pre><code>遍历到[i, j, k]时，d[i] += k, d[j + 1] -= k 
最后再还原</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   暴力法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : bookings)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = arr[<span class="number">0</span>]; i &lt;= arr[<span class="number">1</span>]; i++)</span><br><span class="line">                ans[i - <span class="number">1</span>] += arr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    差分法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//d[i]表示公差，即和前一个航班的的预定数差多少</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : bookings)&#123;</span><br><span class="line">            d[arr[<span class="number">0</span>] - <span class="number">1</span>] += arr[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">1</span>] &lt; n)</span><br><span class="line">                d[arr[<span class="number">1</span>]] -= arr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>原地旋转矩阵</title>
    <url>/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<p>示例 1:</p>
<pre><code>给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]</code></pre><p>示例 2:</p>
<pre><code>给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目意思很简单，就是将矩阵顺时针旋转90°</p>
<p>这道题如果可以换成用辅助空间做那将绝杀，可是换不得</p>
<p>如果要原地修改的话我们只要找到规律也是很简单的</p>
<p>拿示例2举个栗子<br><img src="/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/matrix.png" alt></p>
<p>根据上图，我们可以看出，旋转90°即将每一行竖过来</p>
<p>即一个数原来在哪一列，旋转后就在哪一行，原来在哪一行，旋转后就在（总列数 - 原来的行数 - 1） 这一行</p>
<p>如原来的第3行第1列的14，旋转后到了第1行第0列</p>
<p>总结一下公式就是：arr[j][N - i - 1] = arr[i][j]</p>
<p>根据这个公式，我们就可以获取所有数字旋转后的位置</p>
<p>然而因为要原地，所以直接枚举的话原来的数据会被覆盖掉，所以换一个枚举策略</p>
<p>我们将数组看作n层，如示例2可看作两层<br><img src="/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/exp.png" alt></p>
<pre><code>我们从5开始，5要换到11的位置，在换之前先保存一下原来位置的数据（下同）

然后从11开始，11换到16的位置

然后从16开始，16换到15的位置

然后从15开始，15换到5原来的位置

这样一圈下来，就变成了下图所示</code></pre><p> <img src="/lihaoran0219.github.io/2020/04/07/%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/exp1.png" alt></p>
<p>我们发现外面这一层只剩4个没有换位置，我们只需再从（1，0）的2开始再来一圈就可以将外层全部旋转</p>
<p>外层旋转完毕之后用同样的操作旋转内圈</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//j为每一层的左上角第一个元素的纵坐标</span></span><br><span class="line">        <span class="keyword">int</span> temp = n;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt;=  <span class="number">2</span>)&#123;  <span class="comment">//以层为单位来旋转</span></span><br><span class="line">           cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt; j + temp - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                update(matrix, i, j, matrix[i][j]);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp  -= <span class="number">2</span>;<span class="comment">//处理完一层后，下一层的行数会减2</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对每一个位置（i, j）,我们将他换到旋转后的位置，再将旋转到的位置的原来的元素旋转，重复4次即为一圈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">4</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = j;</span><br><span class="line">        <span class="keyword">int</span> col = n - i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = matrix[row][col]; <span class="comment">//保存原来位置的值，避免被覆盖掉</span></span><br><span class="line">        matrix[row][col] = value; </span><br><span class="line">        cnt++;</span><br><span class="line">        update(matrix, row, col, temp);<span class="comment">//旋转下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短编辑距离问题</title>
    <url>/lihaoran0219.github.io/2020/04/06/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<pre><code>插入一个字符

删除一个字符

替换一个字符</code></pre><p>示例 1：</p>
<pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出：3
解释：
horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)
rorse -&gt; rose (删除 &apos;r&apos;)
rose -&gt; ros (删除 &apos;e&apos;)</code></pre><p>示例 2：</p>
<pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
输出：5
解释：
intention -&gt; inention (删除 &apos;t&apos;)
inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)
enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)
exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)
exection -&gt; execution (插入 &apos;u&apos;)
&lt;!-- more --&gt;</code></pre><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>四月的LeetCode每日一题真的是太难了，快要打不动卡啦！！！</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看完题，我们大致也就知道了编辑距离的意思，就是一个字符串转化为另一个字符串需要的步骤</p>
<p>这道题要求最少操作次数（最短编辑距离），通过最少和只求次数我们基本可以判断使用动态规划</p>
<p>这里先放出状态转移方程，之后再解释</p>
<pre><code>dp[i][j] = k表示str1的前i个字符转化为str2的前j个字符所用的最少操作次数为k

dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1

特殊的，如果i,j指向的字符相同，则dp[i][j] = dp[i - 1][j - 1]</code></pre><p>我们来举个例子：</p>
<p>针对题中的示例1，dp矩阵初始为下图：<br><img src="/lihaoran0219.github.io/2020/04/06/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/init.png" alt><br>当i为0时，dp[i][j] = j</p>
<p>当j为0时，dp[i][j] = i</p>
<p>这是显而易见的，因为对于空串来说，转化为另一个字符串只需插入相应的字符即可</p>
<p>我们来试着计算一下dp[2]这一行：</p>
<p>dp[2][0]即ho –&gt; 空，为2（删除两个字符）</p>
<p>dp[2][1]即ho –&gt; r</p>
<pre><code>我们可选的有插入，删除，替换操作
1.插入：在ho --&gt; 空串的基础上我们再插入一个r即可转化为r,即dp[2][1] = dp[2][0]+1
2.删除：在h --&gt; r的基础上我们再删除o即可转化为r，即dp[2][1] = dp[1][1]+1
3.替换：在h --&gt; 空串的基础上我们只需将o替换为r即可转化为r,即dp[2][1]=dp[1][0]+1
我们选择三种方式中操作数最小的即是dp[2][1]的值</code></pre><p>dp[2][2]即ho –&gt; ros</p>
<pre><code>我们可选的有插入，删除，替换操作
1.插入：在ho --&gt; ro的基础上我们再插入一个s即可转化为ros,即dp[2]2] = dp[2][1]+1
2.删除：在h --&gt;ros的基础上我们再删除o即可转化为ros，即dp[2][2] = dp[1][2]+1
3.替换：在h --&gt; ro的基础上我们只需将o替换为s即可转化为ros,即dp[2][2]=dp[1][1]+1
我们选择三种方式中操作数最小的即是dp[2][2]的值</code></pre><p>  根据以上方法，我们将dp数组填满，最后返回数组的最后一个值即是题目的答案</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">        <span class="comment">//dp[i][j]表示word1的前i个字符转换为word2的前j个字符的最短编辑距离（最少操作数）</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//i = 0，即word1的前0个字符（空串--&gt; word2的前 j个字符），最短编辑距离即为j的取值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 + <span class="number">1</span>; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="comment">//j = 0,即word2的前0个字符（word1的前 i个字符 --&gt;空串），最短距离即为i的取值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 + <span class="number">1</span>; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1 + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2 + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//两个字符相等，在上一步的基础上无需操作，dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line">                 <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//否则在插入，删除，替换三种操作中选一个操作数最小的,然后加1</span></span><br><span class="line">                <span class="comment">//插入：dp[i][j - 1]</span></span><br><span class="line">                <span class="comment">//删除：dp[i - 1][j]</span></span><br><span class="line">                <span class="comment">//替换：dp[i - 1][j - 1]</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j]),dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表倒数第K结点（快慢指针）</title>
    <url>/lihaoran0219.github.io/2020/04/04/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E7%BB%93%E7%82%B9%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p>示例：</p>
<pre><code>输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2
输出： 4</code></pre><a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针是解决这类问题的经典算法，如求链表的中间节点等问题，都可以用到这个思想</p>
<ul>
<li>我们定义两个指针fast和slow，初始指向链表的头结点</li>
<li>先让快指针fast先走k步，然后再让两指针同步走</li>
<li>直到快指针为空（走出了链表），慢指针slow所在的位置即是链表的倒数第k个结点<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;  <span class="comment">//快指针先走k步</span></span><br><span class="line">                <span class="keyword">if</span>(fast == <span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;<span class="comment">//两指针同步走，直到快指针为空</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水问题</title>
    <url>/lihaoran0219.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/lihaoran0219.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/rainwatertrap.png" alt></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p>示例:</p>
<pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6</code></pre> <a id="more"></a>  
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题用单调栈解决</p>
<p><img src="/lihaoran0219.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/example.png" alt></p>
<p>说到栈，我们肯定会想到括号匹配了。<br>我们仔细观察蓝色的部分，可以和括号匹配类比下。<br>每次匹配出一对括号（找到对应的两个柱子），就计算两个柱子之间的水。</p>
<p>我们用栈保存每个柱子。</p>
<p>当遍历柱子的高度的时候，如果当前高度小于栈顶的柱子高度，说明这里出现凹陷，可以接雨水，我们将该柱子下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明凹陷在这里停止，出现了高低高的组合，我们可以计算两个高柱之间的雨水量，算完之后，就把当前柱子继续入栈。</p>
<p>总体的原则就是，</p>
<pre><code>1.当前柱子高度小于栈顶柱子高度，说明有凹陷，可接雨水，入栈当前柱子的下标
2.当前柱子高度大于栈顶柱子高度，说明凹陷到此结束，计算此凹陷能装多雨水，计算完后将此柱子下标入栈
3.计算过程：
    接雨水数量 = 底边长 * 高
    形如高低高的三个柱子才能接到水，
    那么底边长 = 两个高柱子的下标差减1（表现在代码中则是弹出栈顶，当前柱子和新栈顶比较）
    高 = 两高柱子中取较低的柱子的高度，然后减去中间低柱子的高度
    重复计算，直至栈顶柱子的高度大于当前柱子高度</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//维护一个单调栈 </span></span><br><span class="line">            s.push(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(height[i] &lt; height[s.peek()])&#123;<span class="comment">//当前柱子高度小于栈顶柱子高度，直接入栈</span></span><br><span class="line">                    s.push(i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(!s.isEmpty() &amp;&amp; height[i] &gt; height[s.peek()])&#123;<span class="comment">//当前柱子高度大于栈顶柱子高度,计算</span></span><br><span class="line">                    <span class="keyword">int</span> temp = height[s.pop()];<span class="comment">//弹出栈顶元素并记录栈顶柱子高度(即中间低柱子的高度)</span></span><br><span class="line">                    <span class="keyword">if</span>(s.isEmpty())<span class="keyword">break</span>;</span><br><span class="line">                    res += ((i - s.peek() - <span class="number">1</span>) * (Math.min(height[s.peek()], height[i]) - temp));</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(i);<span class="comment">//计算完后将当前柱子入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>生命游戏（复合标志的使用）</title>
    <url>/lihaoran0219.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。</p>
<p>每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。</p>
<p>每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<pre><code>（1）如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
（2）如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
（3）如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
（4）如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</code></pre><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<p>示例：</p>
<pre><code>输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]</code></pre><p>进阶：</p>
<pre><code>* 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。

* 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</code></pre><a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果用一个新数组记录每个细胞的下一状态，那么这道题很简单，只需模拟过程即可</p>
<p>这里要求原地修改数组，我们可以先遍历一遍数组，根据四条规则用复合标志标记每一个细胞的状态</p>
<p>复合标志可以记录每个细胞的原始状态和一次更新后的状态</p>
<p>我们通过四条生存定律举个例子：</p>
<pre><code>（1）如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
        活细胞 --&gt; 死细胞   标记为-1
（2）如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
        活细胞 --&gt; 活细胞 仍为1
（3）如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
        活细胞 --&gt; 死细胞  标记为-1
（4）如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
        死细胞 --&gt; 活细胞  标记为2</code></pre><p>状态更新完后活细胞被标记为1或2，死细胞被标记为-1</p>
<p>然后我们就可以再遍历一遍数组将细胞的状态恢复为0或1</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> live = <span class="number">0</span>; <span class="comment">//记录周围的活细胞数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)&#123;<span class="comment">//在细胞周围的八个方向找活细胞</span></span><br><span class="line">                    <span class="keyword">int</span> newX = i + dx[k];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(newX &lt; <span class="number">0</span> || newX &gt;= board.length || newY &lt; <span class="number">0</span> || newY &gt;= board[<span class="number">0</span>].length)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(board[newX][newY] == <span class="number">1</span> || board[newX][newY] == -<span class="number">1</span>)<span class="comment">//原始状态是活细胞被标记为了1或-1</span></span><br><span class="line">                        live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((live &lt; <span class="number">2</span> || live &gt; <span class="number">3</span>) &amp;&amp; board[i][j] == <span class="number">1</span>)board[i][j] = -<span class="number">1</span>;<span class="comment">//活细胞--&gt;死细胞</span></span><br><span class="line">                <span class="keyword">if</span>(live == <span class="number">3</span> &amp;&amp; board[i][j] == <span class="number">0</span>)board[i][j] = <span class="number">2</span>; <span class="comment">//死细胞--&gt;活细胞</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*恢复状态为0或1*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == -<span class="number">1</span>)</span><br><span class="line">                    board[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> || board[i][j] == <span class="number">2</span>)</span><br><span class="line">                    board[i][j] = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫环问题</title>
    <url>/lihaoran0219.github.io/2020/03/30/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：</p>
<pre><code>输入: n = 5, m = 3
输出: 3</code></pre><p>示例 2：</p>
<pre><code>输入: n = 10, m = 17
输出: 2</code></pre><p>限制：</p>
<pre><code>1 &lt;= n &lt;= 10^5
1 &lt;= m &lt;= 10^6</code></pre><p>题目出自LeetCode  面试题62. 圆圈中最后剩下的数字</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。</p>
<p>那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</p>
<p>由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。</p>
<p>当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。</p>
<p>因此有 f(n, m) = (m % n + x) % n = (m + x) % n。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(lastRemaining3(<span class="number">55</span>, <span class="number">107</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法一：ArrayList代替环形链表进行模拟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (cur + m - <span class="number">1</span>) % list.size();</span><br><span class="line">            list.remove(index);</span><br><span class="line">            cur = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法二：递归</span></span><br><span class="line"><span class="comment">    将问题分解：</span></span><br><span class="line"><span class="comment">    首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。</span></span><br><span class="line"><span class="comment">    那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</span></span><br><span class="line"><span class="comment">    由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。</span></span><br><span class="line"><span class="comment">    当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。</span></span><br><span class="line"><span class="comment">    因此有 f(n - 1, m) = (m % n + x) % n = (m + x) % n。</span></span><br><span class="line"><span class="comment">    我们递归计算 f(n, m), f(n - 1, m), f(n - 2, m), ... 直到递归的终点 f(1, m)。当序列长度为 1 时，一定会留下唯一的那个元素，它的编号为 0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastRemaining2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = lastRemaining2(n - <span class="number">1</span>, m);<span class="comment">//上一次删除的位置</span></span><br><span class="line">        <span class="keyword">return</span> (x + m) % n; <span class="comment">//在上次删除的位置再走m步</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法三：将递归改为迭代形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastRemaining3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res = (res + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单词的压缩编码（Trie字典树的应用）</title>
    <url>/lihaoran0219.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%EF%BC%88Trie%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p>
<p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p>
<p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p>
<p>示例：</p>
<pre><code>输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]
输出: 10
说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。</code></pre><p>提示：</p>
<pre><code>1 &lt;= words.length &lt;= 2000
1 &lt;= words[i].length &lt;= 7
每个单词都是小写字母 。</code></pre><a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根据示例，将”time”, “me”, “bell”三个单词变成了”time#bell#”</p>
<p>我们可以发现indexes = [0, 2, 5]是3个单词在压缩后的字符串中的起始索引</p>
<p>那么我们可以判断一个字符串是否是另一个字符串的后缀（如me是time的后缀，则被舍弃）</p>
<p>这样的话很容易想到了字典树（前缀树），这里先来看看：</p>
<p>假设有8个单词”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”</p>
<p>他们在前缀树中是这样存储的：</p>
<p><img src="/lihaoran0219.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%EF%BC%88Trie%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/Trie.png" alt="图片来自LettCode"></p>
<p>前缀树的结点定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> value;</span><br><span class="line">            TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>插入操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (cur.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据字典树的特性，我们可以将每一个字符串逆序存入树中</p>
<p>逆序是为了判断掉当前单词是否是某一个单词的后缀</p>
<p>还需要注意：插入时字符串长度长的要先插入</p>
<p>如time和me,如果先插入me，那么两个单词都可完成插入操作，无法正确判断</p>
<p>基于此，只需要对插入操作的代码稍作改动即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">        TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            TrieNode cur = root;</span><br><span class="line">            <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标记是否插入字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = chars.length - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//字符串逆序存储，这样的目的是如果某个单词是别的单词的后缀，那么就不会执行插入操作</span></span><br><span class="line">                <span class="keyword">int</span> index = chars[i] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.children[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cur.children[index] = <span class="keyword">new</span> TrieNode(chars[i]);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.children[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag ? word.length() + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> value;</span><br><span class="line">            TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">int</span> sumLen = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(words, (s1, s2) -&gt; s2.length() - s1.length());<span class="comment">//根据字符串的长度降序排序（这里用jdk8的lambda表达式）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            sumLen += root.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>523.连续的子数组和</title>
    <url>/lihaoran0219.github.io/2020/03/26/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
<p>示例 1:</p>
<pre><code>输入: [23,2,4,6,7], k = 6
输出: True
解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。</code></pre><p>示例 2:</p>
<pre><code>输入: [23,2,6,4,7], k = 6
输出: True
解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</code></pre><p>说明:</p>
<p>数组的长度不会超过10,000。</p>
<p>你可以认为所有数字总和在 32 位有符号整数范围内。</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一-前缀和数组（O-N-2-）"><a href="#方法一-前缀和数组（O-N-2-）" class="headerlink" title="方法一 前缀和数组（O(N^2)）"></a>方法一 前缀和数组（O(N^2)）</h4><pre><code>pre数组存放原数组的前缀和，即pre[i]表示原数组的前i个元素的和

枚举每一个子数组（元素个数大于1），判断和是否是k的倍数

其中nums[i] ~ nums[j]这一子数组的和为pre[j] - pre[i - 1]</code></pre><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;<span class="comment">//修改原数组化为前缀和数组，即nums[i]表示前i位之和</span></span><br><span class="line">               nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">if</span>(check(nums[i], k))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123; <span class="comment">//枚举nums[i] ~ nums[j]之和，判断是否是k的倍数</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; nums.length; j++)&#123; <span class="comment">//第i位到第j位之和在前缀和数组中为nums[j] - nums[i - 1];</span></span><br><span class="line">                   <span class="keyword">if</span>(check(nums[j] - nums[i], k))</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//判断num是否为k的倍数</span></span><br><span class="line">           <span class="keyword">return</span> k == <span class="number">0</span> ? num == k : num % k == <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二-HashMap优化的前缀和数组-O-N"><a href="#方法二-HashMap优化的前缀和数组-O-N" class="headerlink" title="方法二 HashMap优化的前缀和数组(O(N))"></a>方法二 HashMap优化的前缀和数组(O(N))</h4><pre><code>和方法一类似，方法二不同在于用HashMap存储前缀和，并且每次存储时都将结果对k取余

结果以 (前i位之和sum % k -- i)键值对的形式存储

遍历数组，如果key不存在，则加入哈希表，如果存在，说明存在子数组和为k的倍数

原理：
     因为每一个key都是前缀和对k取余的结果

     所以当遇到相同的key时，说明之间的差值一定是k的倍数,即：
        若
          m % k = a
          (m + n) % k = a
        则 n % k = 0
     由此可得出：
        前j项之和对k取余的结果 == 前i项之和对k取余的结果（j &gt; i)时
        nums[i + 1] ~ nums[j]这一段子数组的和是k的倍数（j - i &gt; 1）</code></pre><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       解法2：HashMap优化前缀和数组</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           Map&lt;Integer, Integer&gt;  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           map.put(<span class="number">0</span>, -<span class="number">1</span>);<span class="comment">//防止出现&#123;0，0&#125;，k=0的情况</span></span><br><span class="line">           <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">               sum += nums[i];</span><br><span class="line">               <span class="keyword">if</span>(k != <span class="number">0</span>)</span><br><span class="line">                   sum %= k;  <span class="comment">//每次存前i位的和对k的余数</span></span><br><span class="line">               <span class="keyword">if</span>(!map.containsKey(sum))</span><br><span class="line">                   map.put(sum, i);</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(i - map.get(sum) &gt; <span class="number">1</span>)  <span class="comment">//必须是两个及以上元素之和</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>779.第K个语法符号</title>
    <url>/lihaoran0219.github.io/2020/03/23/779.%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p>
<p>给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）</p>
<p>例子:</p>
<pre><code>输入: N = 1, K = 1
输出: 0

输入: N = 2, K = 1
输出: 0

输入: N = 2, K = 2
输出: 1

输入: N = 4, K = 5
输出: 1

解释:
第一行: 0
第二行: 01
第三行: 0110
第四行: 01101001</code></pre><p>注意：</p>
<p>N 的范围 [1, 30].<br>K 的范围 [1, 2^(N-1)].</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以多写几行数据，不难发现规律：</p>
<p>第N行有 2^(N-1) 个字符，且前一半和上一行的字符相同，后一半是对前一半的每个字符取反（0变1，1变0）</p>
<p>这样我们可以对要找的某一个字符追根溯源，找到他是从哪个字符变化而来的，这一过程用递归或迭代很容易完成</p>
<p>例如：</p>
<p>第5行的数据为： 01101001 10010110 </p>
<p>若N = 5, K = 14</p>
<p>解答过程：</p>
<pre><code>N = 5:    K = 14 &gt; 8,在后一半，是由前一半的第6个数取反而来,而第6个数又是由第第4行得来

N = 4: K = 6 &gt; 4,在后一半，是由前一半的第2个数取反而来，而第2个数又是由第3行得来

N = 3: K = 2 &lt;= 2,在前一半，是由第2行的第2个数得来

N = 2: K = 2 &gt; 1,在后一半，是由前一半的第1个数取反而来，而第1个数又是由第1行得来（第一行为0）

结束，过程中共取反3次，即是由0取反3次得来，所以结果为1</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//记录取反的次数</span></span><br><span class="line">        <span class="keyword">while</span>(N &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, N - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(K &gt; mid)&#123;<span class="comment">//在这一行的后一半，说明是由前一半的第K - mid个数取反而来</span></span><br><span class="line">                cnt++;</span><br><span class="line">                K -= mid;</span><br><span class="line">            &#125;</span><br><span class="line">            N--;  </span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快慢指针之链表中间节点</title>
    <url>/lihaoran0219.github.io/2020/03/23/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B9%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>示例 1：</p>
<pre><code>输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</code></pre><p>示例 2：</p>
<pre><code>输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</code></pre><p>提示：</p>
<p>给定链表的结点数介于 1 和 100 之间。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>定义快慢指针：</p>
<p>初始都指向链表的头结点</p>
<p>慢指针每次走一步，快指针每次走两步</p>
<p>当快指针走到链表最末端或者为空时，慢指针正好走到了链表的中间</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="链表无头结点"><a href="#链表无头结点" class="headerlink" title="链表无头结点"></a>链表无头结点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head; <span class="comment">//快指针</span></span><br><span class="line">        ListNode low = head; <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表有头结点"><a href="#链表有头结点" class="headerlink" title="链表有头结点"></a>链表有头结点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head; <span class="comment">//快指针</span></span><br><span class="line">        ListNode pre = head; <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = (p.next == <span class="keyword">null</span> ? p.next : p.next.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>650.只有两个键的键盘</title>
    <url>/lihaoran0219.github.io/2020/03/21/650.%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p>
<p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</p>
<p>Paste (粘贴) : 你可以粘贴你上一次复制的字符。</p>
<p>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。</p>
<p>输出能够打印出 n 个 ‘A’ 的最少操作次数。</p>
<p>示例 1:</p>
<pre><code>输入: 3
输出: 3
解释:
最初, 我们只有一个字符 &apos;A&apos;。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 &apos;AA&apos;。
第 3 步, 我们使用 Paste 操作来获得 &apos;AAA&apos;。</code></pre><p>说明:</p>
<p>n 的取值范围是 [1, 1000] 。</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>当n为质数时，只能一个一个复制得到n个’A’</p>
<p>当n不为质数时，我们可以找到n除了自身最大的因数：</p>
<pre><code>例如：n=15
15的最大因数为5，可由5个&apos;A&apos;再复制两次得到
可得递归方程为：
假设g是n除了自身最大的因数
f(n) = f(g) + n / g  n不是质数      （实际是f(g) + 1  + n/g - 1）
f(n) = n             n是质数</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//递归出口</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)&#123;  <span class="comment">//找n的最大因数</span></span><br><span class="line">           <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> minSteps(i) + n / i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i / <span class="number">2</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = dp[j] + i / j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>水壶问题（裴蜀定理的应用）</title>
    <url>/lihaoran0219.github.io/2020/03/21/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%88%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p>示例 1: (From the famous “Die Hard” example)</p>
<pre><code>输入: x = 3, y = 5, z = 4
输出: True
解释：将y装满，再倒给x,此时y还剩2
     把x清空，将y中剩的2L倒给x(此时x还能装1L)           
     将y装满，再给x倒水将x装满，此时y中剩下的恰好是4L</code></pre><p>示例 2:</p>
<pre><code>输入: x = 2, y = 6, z = 5
输出: False</code></pre><a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的意思很简单，就是求一个x升的水壶和一个y升的水壶能否装z升的水，即：</p>
<pre><code>ax + by = z是否有解</code></pre><p>这里先引用百度对于裴祖公式的解释</p>
<pre><code>在数论中，裴蜀定理是一个关于最大公约数（或最大公约式）的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，</code></pre><p>说明了<strong>对任何整数a、b和它们的最大公约数d</strong>，关于未知数x和y的线性丢番图方程（称为裴蜀等式）：</p>
<p><strong>ax + by = m有解当且仅当m是d的倍数。</strong></p>
<pre><code>裴蜀等式有解时必然有无穷多个整数解 ，每组解x、y都称为裴蜀数，可用辗转相除法求得。

例如，12和42的最大公因子是6，则方程12x + 42y = 6有解。
事实上有（-3）×12 + 1×42 = 6及4×12 + (-1）×42 = 6。
特别来说，方程 ax + by = 1 有解当且仅当整数a和b互素。
裴蜀等式也可以用来给最大公约数定义：d其实就是最小的可以写成ax + by形式的正整数。这个定义的本质是整环中“理想”的概念。因此对于多项式整环也有相应的裴蜀定理。</code></pre><p><strong>它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.</strong></p>
<p>因此，我们只需判断x和y的最大公约数能否被z整除即可（在此基础上，还需要z &lt;= x + y,否则两个水壶装不下）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gcd = gcd(x, y);<span class="comment">//最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(gcd == <span class="number">0</span>)<span class="keyword">return</span> z &lt;= x + y;</span><br><span class="line">        <span class="keyword">return</span> z % gcd == <span class="number">0</span> &amp;&amp; z &lt;= x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//返回a,b的最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>topK问题的两种经典解法</title>
    <url>/lihaoran0219.github.io/2020/03/20/topK%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>示例 1：</p>
<pre><code>输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]</code></pre><p>示例 2：</p>
<pre><code>输入：arr = [0,1,2,1], k = 1
输出：[0]</code></pre><a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这道题是经典的topK问题，本题是求一组数据中最小的K个数据，与之相同的还有求一组数据中最大的k个数据。方法都是相同的，这里介绍了两种解决topK问题的经典算法。</p>
<h3 id="方法一-堆"><a href="#方法一-堆" class="headerlink" title="方法一 堆"></a>方法一 堆</h3><p>比较直观的想法是使用堆数据结构来辅助得到最小的 k 个数。</p>
<p>堆的性质是每次可以找出最大或最小的元素。</p>
<p>我们可以使用一个大小为 k 的最大堆（大顶堆），将数组中的元素依次入堆，当堆的大小超过 k 时，便将多出的</p>
<p>元素从堆顶弹出。我们以数组 {5, 4, 1, 3, 6, 2, 9},k=3 为例展示元素入堆的过程，如下面动图所示：</p>
<p><img src="/lihaoran0219.github.io/2020/03/20/topK%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95/heap.gif" alt></p>
<p>这样，<strong>由于每次从堆顶弹出的数都是堆中最大的，最小的 k 个元素一定会留在堆里。</strong>这样，把数组中的元素全部入堆之后，堆中剩下的 k 个元素就是最大的 k 个数了。</p>
<p>在这里使用 Java 中的 PriorityQueue实现堆数据结构。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">    <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (i1, i2) -&gt; Integer.compare(i2, i1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">        <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123;</span><br><span class="line">            heap.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">            heap.poll(); <span class="comment">// 删除堆顶最大元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">        res[j++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法的复杂度分析："><a href="#算法的复杂度分析：" class="headerlink" title="算法的复杂度分析："></a>算法的复杂度分析：</h4><ul>
<li><p>由于使用了一个大小为 k 的堆，空间复杂度为 O(k)；</p>
</li>
<li><p>入堆和出堆操作的时间复杂度均为 O(log k)，每个元素都需要进行一次入堆操作，故算法的时间复杂度为 O(nlogk)。</p>
</li>
</ul>
<h3 id="方法二-快速选择算法（快排的变形）"><a href="#方法二-快速选择算法（快排的变形）" class="headerlink" title="方法二 快速选择算法（快排的变形）"></a>方法二 快速选择算法（快排的变形）</h3><p>Top K 问题的另一个解法就比较难想到，需要在平时有算法的积累。</p>
<p>实际上，“查找第 k 大的元素”是一类算法问题，称为选择问题。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。</p>
<p>这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p>
<p>在快速排序中，有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边。</p>
<p>这个 partition 操作是原地进行的，需要 O(n) 的时间，接下来，快速排序会递归地排序左右两侧的数组。</p>
<p>而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p>
<p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 q，也就是说，左侧的数组有q 个元素，是原数组中最小的 q个数。那么：</p>
<ul>
<li>若 k = q，我们就找到了最小的 k 个数，就是左侧的数组；</li>
<li>若 k &lt; q ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li>
<li>若 k &gt; q，则左侧数组中的 q 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k- q 个数，对右侧数组递归地 partition 即可。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        quickSelect(arr, k, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> q = partition(arr, begin, end);</span><br><span class="line">            <span class="keyword">if</span>(q == k)<span class="keyword">return</span>;  <span class="comment">//q左侧的k个数是最小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(q &gt; k)<span class="comment">//说明最小的k个数一定在左侧，继续在左侧划分</span></span><br><span class="line">                quickSelect(arr, k, begin, q - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//说明右侧还有k - q个最小的元素</span></span><br><span class="line">                quickSelect(arr,k, q + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123; <span class="comment">//和快排的partition算法相同</span></span><br><span class="line">		<span class="keyword">int</span> i = lo;</span><br><span class="line">		<span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> v = a[lo];<span class="comment">// 基准元素</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (a[++i] &lt; v) &#123; <span class="comment">// 指针i从前往后找到比基准元素大的值停下</span></span><br><span class="line">				<span class="keyword">if</span> (i == hi)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (a[--j] &gt; v) &#123; <span class="comment">// 指针j从后往前找到比基准元素小的值停下</span></span><br><span class="line">				<span class="keyword">if</span> (j == lo)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			swap(a, i, j);<span class="comment">// i,j指向的值交换位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		swap(a, lo, j);<span class="comment">// 一趟走完此时j指向的位置是基准元素应该在的位置</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此时 a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></span><br><span class="line">		<span class="keyword">return</span> j;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法的复杂度分析：-1"><a href="#算法的复杂度分析：-1" class="headerlink" title="算法的复杂度分析："></a>算法的复杂度分析：</h4><ul>
<li><p>空间复杂度 O(1)，不需要额外空间。</p>
</li>
<li><p>时间复杂度的分析方法和快速排序类似。由于快速选择只需要递归一边的数组，时间复杂度小于快速排序，期望时间复杂度为 O(n)，最坏情况下的时间复杂度为 O(n^2)。</p>
</li>
</ul>
<h3 id="两种方法的优劣性比较"><a href="#两种方法的优劣性比较" class="headerlink" title="两种方法的优劣性比较"></a>两种方法的优劣性比较</h3><p>看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：</p>
<p>第一，算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</p>
<p>第二，算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</p>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>264.第N个丑数</title>
    <url>/lihaoran0219.github.io/2020/03/19/264-%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例:</p>
<pre><code>输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</code></pre><p>说明:  </p>
<ol>
<li>1是丑数。</li>
<li>n不超过1690。</li>
</ol>
<a id="more"></a>

<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>首先想到的是暴力法，逐个判断每一个数是否是丑数，意料之中的超时！！</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUgly(result)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用优先队列（小顶堆）</p>
<p>堆中初始为有元素1，然后每次弹出堆中最小的丑数num并将num * 2,num * 3, num * 5加入到堆中</p>
<p>这里我使用Java中的TreeSet,加入的数自动排序并去除重复值，避免了加入重复值如2 * 3 = 6 和 3 * 2 = 6</p>
<p>重复n次后就找到了第n个丑数（耗时105ms,并不理想！！）</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        set.add(<span class="number">1l</span>);</span><br><span class="line">        <span class="keyword">while</span>(count &lt; n)&#123;</span><br><span class="line">            res = set.pollFirst(); <span class="comment">//弹出第一个元素（当前集合中最小的丑数）</span></span><br><span class="line">            set.add(res * <span class="number">2</span>);</span><br><span class="line">            set.add(res * <span class="number">3</span>);</span><br><span class="line">            set.add(res * <span class="number">5</span>);</span><br><span class="line">            count++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>动态规划（三指针法）</p>
<p>我们先模拟手写丑数的过程：</p>
<p>初始为1，1乘2 1乘3 1乘5，现在是{1,2,3,5}</p>
<p>轮到2，2乘2 2乘3 2乘5，现在是{1,2,3,4,5,6,10}</p>
<p>手写的过程和方法二的小顶堆很像，但是怎么做到提前排序呢</p>
<p>小顶堆的方法是先存再排，dp的方法则是先排再存</p>
<p>我们设3个指针p2,p3,p5</p>
<p>代表的是第几个数的2倍、第几个数3倍、第几个数5倍</p>
<p>动态方程dp[i] = min(dp[p2]<em>2,dp[p3]</em>3,dp[p5]*5)</p>
<p>小顶堆是一个元素出来然后存3个元素</p>
<p>动态规划则是标识3个元素，通过比较他们的2倍、3倍、5倍的大小，来一个一个存</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = Math.min(Math.min(dp[p2] * <span class="number">2</span>, dp[p3] * <span class="number">3</span>), dp[p5] * <span class="number">5</span>);<span class="comment">//选三个数中的最小值</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p2] * <span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p3] * <span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p5] * <span class="number">5</span>) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>409. 最长回文串</title>
    <url>/lihaoran0219.github.io/2020/03/19/409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<pre><code>输入:
&quot;abccccdd&quot;

输出:
7

解释:
我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</code></pre><a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于一个回文串，如果长度为偶数时，那么所有的字符都出现偶数次，如abccba</p>
<p>如果长度为奇数时，只有一个字符出现奇数次，如ababa</p>
<p>基于此，我们只需统计给定字符串中每个字符出现的次数，然后每个字符尽可能多的拿偶数个，</p>
<p>最后如果还有剩余的字符，再拿一个，这样的策略保证构造的回文串最长</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];<span class="comment">// 记录s中每个字符出现的次数 A(65) -- z(122)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray())</span><br><span class="line">			rec[ch - <span class="string">'A'</span>]++;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 记录最长回文串的长度</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rec.length; i++) &#123;</span><br><span class="line">			res += rec[i] / <span class="number">2</span> * <span class="number">2</span>; <span class="comment">// 每一个字符拿偶数个</span></span><br><span class="line">			<span class="keyword">if</span>(rec[i]  % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; res % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">//回文串中最多有1个字符出现奇数次，所以有奇数个的时候拿一个</span></span><br><span class="line">                res++; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客增加评论留言功能</title>
    <url>/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近用hexo搭建了一个博客，这是一个用来生成静态博客的开源框架，要想开启评论功能，我们在这里借助后端云平台LeanCloud</p>
<p>nexT主题集成了很多评论插件，这里采用Valine</p>
<a id="more"></a>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-前往LeanCloud官网注册账号"><a href="#1-前往LeanCloud官网注册账号" class="headerlink" title="1.前往LeanCloud官网注册账号"></a>1.前往<a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud官网</a>注册账号</h4><h4 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2.创建应用"></a>2.创建应用</h4><p><img src="/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/new.jpg" alt></p>
<h4 id="3-进入应用→设置→应用key-获取你的appid和appkey"><a href="#3-进入应用→设置→应用key-获取你的appid和appkey" class="headerlink" title="3.进入应用→设置→应用key 获取你的appid和appkey"></a>3.进入应用→设置→应用key 获取你的appid和appkey</h4><p><img src="/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/keys.jpg" alt></p>
<h4 id="4-打开主题配置文件（blog-themes-next-config-yml）"><a href="#4-打开主题配置文件（blog-themes-next-config-yml）" class="headerlink" title="4.打开主题配置文件（blog/themes/next/_config.yml）"></a>4.打开主题配置文件（blog/themes/next/_config.yml）</h4><pre><code>* 搜索valine
* 将enable设置为true
* 将获取的id填入相应的位置</code></pre><p><img src="/lihaoran0219.github.io/2020/03/19/hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD/valine.jpg" alt></p>
<h4 id="大功告成啦！！！"><a href="#大功告成啦！！！" class="headerlink" title="大功告成啦！！！"></a>大功告成啦！！！</h4>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>703. 数据流中的第K大元素</title>
    <url>/lihaoran0219.github.io/2020/03/18/703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>
<p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 </p>
<p>KthLargest.add，返回当前数据流中第K大的元素。</p>
<p>示例:</p>
<pre><code>int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8</code></pre><p>说明:<br>你可以假设 nums 的长度≥ k-1 且k ≥ 1。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过维护一个小顶堆实现</p>
<p>Java中有PriorityQueue类实现了优先级队列，默认小顶堆，可通过传入外部比较器实现大顶堆</p>
<p>小顶堆可实现队中只有K个最大的元素</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq;  <span class="comment">//优先级队列（小顶堆）</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pq.size() &lt; k) &#123; <span class="comment">//队中不满K个元素时继续入队</span></span><br><span class="line">            pq.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pq.peek() &lt; val) &#123;<span class="comment">//只有比队首元素大才入队，保证队中只有K个元素</span></span><br><span class="line">            pq.poll();<span class="comment">//弹出队首元素</span></span><br><span class="line">            pq.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>863.矩形重叠</title>
    <url>/lihaoran0219.github.io/2020/03/18/863-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p>
<p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形，判断它们是否重叠并返回结果。</p>
<p>示例 1：</p>
<pre><code>输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true</code></pre><p>示例 2：</p>
<pre><code>输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false</code></pre><a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用反证思想，判断两个矩形是否不重叠显然要简单一些</p>
<p>固定一个矩形，另一个矩形有四种情况：</p>
<pre><code>矩形 rec2 在矩形 rec1 的左侧；（rec2右下角横坐标小于等于rec1左下角横坐标）

矩形 rec2 在矩形 rec1 的右侧；（rec2左下角横坐标大于等于rec1右下角横坐标）

矩形 rec2 在矩形 rec1 的上方；（rec2左下角纵坐标大于等于rec1左下角纵坐标）

矩形 rec2 在矩形 rec1 的下方  （rec2左上角纵坐标小于等于rec1左下角纵坐标）</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(rec2[<span class="number">1</span>] &gt;= rec1[<span class="number">3</span>]||  <span class="comment">//rec2在rec1上方</span></span><br><span class="line">		 rec2[<span class="number">3</span>] &lt;= rec1[<span class="number">1</span>] ||  <span class="comment">//rec2在rec1下方	</span></span><br><span class="line">		 rec2[<span class="number">2</span>] &lt;= rec1[<span class="number">0</span>]	|| <span class="comment">//rec2在rec1左方</span></span><br><span class="line">		 rec2[<span class="number">0</span>] &gt;= rec1[<span class="number">2</span>]	);  <span class="comment">//rec2在rec1右方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划和贪心+二分查找解决最长上升子序列问题</title>
    <url>/lihaoran0219.github.io/2020/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%A7%A3%E5%86%B3%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h2 id="解法一：动态规划（O-n-2-）"><a href="#解法一：动态规划（O-n-2-）" class="headerlink" title="解法一：动态规划（O(n^2)）"></a>解法一：动态规划（O(n^2)）</h2><a id="more"></a>
<p>dp[i]表示以array[i]结尾的最长上升子序列的长度<br>dp[i] = max(dp[0] – dp[j]) + 1 (其中j &lt; i 且 array[j] &lt; array[i])</p>
<p>例： 1,7,3,5,9,4,8</p>
<p>（1）dp[i]的元素初值都为1</p>
<p>（2）dp[0]表示以1结尾的最长上升子序列的长度，为1 </p>
<p>（3）dp[1]表示以7结尾的最长上升子序列的长度:</p>
<ul>
<li>看dp[0],因为array[0] &lt; array[1],所以dp[1] = dp[0] + 1 = 2</li>
</ul>
<p>（4）dp[2]表示以7结尾的最长上升子序列的长度:</p>
<pre><code>看dp[0],dp[1],只有array[0] &lt; array[2]

所以dp[2] = dp[0] + 1 = 2</code></pre><p>（5）dp[3]表示以5结尾的最长上升子序列的长度:</p>
<pre><code>看dp[0],dp[1],dp[2],array[0] &lt; array[3],array[2] &lt; array[3]

dp[0]和dp[2]中取最大值dp[2] = 2

所以dp[3] = dp[2] + 1 = 3</code></pre><p>（6）dp[4]表示以9结尾的最长上升子序列的长度:</p>
<pre><code>看dp[0],dp[1],dp[2],dp[3]

array[0],array[1],array[2],array[3]都小于&lt;array[4]

dp[0],dp[1],dp[2],dp[3]中取最大值dp[3] = 3

所以dp[3] = dp[3] + 1 = 4</code></pre><p>（7）dp[5]表示以4结尾的最长上升子序列的长度:</p>
<pre><code>看dp[0],dp[1],dp[2],dp[3]，dp[4]

array[0],array[2]小于&lt;array[5]

dp[0],dp[2]中取最大值dp[2] = 2

所以dp[3] = dp[2] + 1 = 3</code></pre><p>（8）dp[6]表示以8结尾的最长上升子序列的长度:</p>
<pre><code>看dp[0],dp[1],dp[2],dp[3],dp[4],dp[5]

array[0],array[1],array[2],array[3],array[5]都小于&lt;array[6]

dp[0],dp[1],dp[2],dp[3],dp[5]中取最大值 3

所以dp[3] = 3 + 1 = 4</code></pre><p>(9)遍历完数组array,求dp数组中的最大值即为最长上升子序列的长度</p>
<h2 id="解法二：贪心-二分查找（O-nlogn-）"><a href="#解法二：贪心-二分查找（O-nlogn-）" class="headerlink" title="解法二：贪心+ 二分查找（O(nlogn)）"></a>解法二：贪心+ 二分查找（O(nlogn)）</h2><p>对于以某一个数结尾的最长上升子序列，当然是结尾的数越小越好    </p>
<p>创建一个list,初始有一个元素array[0]</p>
<p>从下标为1处开始扫描数组array</p>
<p>如果比list中的最后一个数大，说明可构成上升子序列，直接加入到list中</p>
<p>如果比list中的最后一个数小，则找到list中第一个大于或等于这个数的元素替换</p>
<p>查找用二分查找实现</p>
<p>最终list的长度即为最长上升子序列的长度</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">        <span class="comment">//动态规划法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">            Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(array[j] &lt; array[i]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[j] &gt; max) </span><br><span class="line">                            max = dp[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = max + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxInArray(dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxInArray</span><span class="params">(<span class="keyword">int</span>[] dp)</span> </span>&#123;<span class="comment">//返回dp数组中的最大值</span></span><br><span class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[i] &gt; max)</span><br><span class="line">				max = dp[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//贪心 + 二分查找 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//res中的元素保持升序</span></span><br><span class="line">        res.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; res.get(res.size() - <span class="number">1</span>))</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.set(binarySearch(res, nums[i]), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; res, <span class="keyword">int</span> key)</span></span>&#123;<span class="comment">//找到list中第一个大于key的值，返回下标</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = res.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(res.get(mid) &lt; key)  <span class="comment">//注意：if else 的位置不能换</span></span><br><span class="line">	                l = mid + <span class="number">1</span>;</span><br><span class="line">	            <span class="keyword">else</span></span><br><span class="line">	                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
